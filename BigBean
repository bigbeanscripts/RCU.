local Library = loadstring(game:HttpGetAsync("https://github.com/ActualMasterOogway/Fluent-Renewed/releases/latest/download/Fluent.luau"))()
local SaveManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/bigbeanscripts/Pet-Warriors/refs/heads/main/test"))()
local InterfaceManager = loadstring(game:HttpGetAsync("https://raw.githubusercontent.com/ActualMasterOogway/Fluent-Renewed/master/Addons/InterfaceManager.luau"))()
loadstring(game:HttpGet("https://raw.githubusercontent.com/SenhorLDS/ProjectLDSHUB/refs/heads/main/Anti%20AFK"))()

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local CollectionService = game:GetService("CollectionService")
local LocalPlayer = Players.LocalPlayer

local Knit
local ClickService, EggService, RebirthService, TreeService, AxeService, InventoryService,
      PetService, RewardService, UpgradeService, SeasonService, AuraService, EventService,
      OrbService, FarmService, BuildingService, ClanService, LumberjackService
local DataController, EggController, TreeController, HatchingController, AuraController,
      MapController, OrbController, ItemController, SoundController, FarmController, BuildingController

local Functions, Util, Values, seasonVariables, seasonUtils, seasonTiersList

local Window, Tabs, EggDropdown, HatchAmount, LuckyEgg, AutoHatch, HideAnimationToggle,
      SelectTreesDropdown, AutoCutTreesToggle, lowercooldown, BypassStrength, AutoEquip, UpgradeAxe,
      explorerroom, ActivateLeversSection, ClaimSection, AncientWheel, ClanWheel, AncientMerchantSection, PassSection, Aura, EventSection

local selectedEgg, selectedAmount, useLuckyEggs, selectedTrees, autoBreakRunning, isAutoEquipAxeEnabled,
      isAutoUpgradeEnabled, originalSelectedObjects, originalAutoCutState, treeToggleThread, petDisplayToId,
      angelQuestToggle, allowedDiceDropdown, originalEggSelection, originalHatchAmount, originalTreeSelection,
      originalAutoCutState, originalAutoHatchState, angelQuestEnabled, isAutoCollectEnabled, autoClaimThread, pickupStarsThread,
      autoClaimAllChestsThread, originalIsInGroup, supplyDropThread, isAutoSpinEnabled, isAutoSpinEnabled1, isAutoBuyEnabled,
      autoSteampunkToggles, isAutoCraftEnabled, originalAutoCraftSettings, autoCraftDropdown, autoCraftBuildingMap,
      ResourceStatusParagraph, selectedDiceItems, autoRollThread, isAuraHidden, originalAuraFuncs, isAutoBreakingMeteors

local BuildUI, getUnlockedRebirthOptions, GetBestRebirthOption, updateRebirthDropdown, performRebirth,
      TerminateThread, CreateThread, formatNumber, getLuckyIdForEggName, getTreeTypes, mapWoodToTreeWorld,
      getLumberId, getActiveTreesInGroup, updateAxeUpgradeStatus, manageTreeToggleCycle, getAllNonWoodRequirements,
      getAllFarms, getAllFarmsWithOptions, getAllFarmsForClaim, isFarmReady, getPlayerPetOptions,
      updatePetStatusParagraph, updateAngelQuestStatus, getAllAuraDice, getCurrentQuestType, findBestPotion,
      getAvailableAuraDice, setupForQuestType, storeOriginalSettings, restoreOriginalSettings, getAllSmoothies,
      getAllMagicPotItems, getAllWoods, canCraftToday, getAllMaps, getAllLumberjackItems, canAffordUpgrade,
      isLumberjackAtWork, getAllUpgradeItems, hasActiveBoost, getUnbuiltBuildings, canAffordBuilding,
      getPrerequisiteChain, getMissingResources, updateResourceStatus, mapWoodToTreeWorldForCraft, claimChestsInUnlockedMaps,
      createClaimToggle, getAllAncientMerchantItems, updateDiceStatus, storeAuraFuncs, hideAuraAnims, restoreAuraAnims

spawn(function()
    while wait(30) do 
        pcall(function() collectgarbage("collect") end)
        gcinfo()
    end
end)

BuildUI = function()

    local ClickSection = Tabs.Main:AddSection("Auto Click")

    local AutoClick =ClickSection:Toggle("AutoClick", {
        Title = "Auto Click",
        Description = "Automatically clicks for you - Extremely fast!",
        Default = false,
        Callback = function(Value)
            _G.AutoClicking = Value
            if Value then
                task.spawn(function()
                    while _G.AutoClicking do
                        ClickService.click._re:FireServer()
                        task.wait(0.001)
                    end
                end)
            end
        end
    })

    local RebirthSection = Tabs.Main:AddSection("Rebirths")

    local selectedRebirthIndex = "Max Unlocked"
    local rebirthDropdown  -- Keep this declaration
    local rebirthOptions = {}
    local isMaxUnlockedSelected = false
    local autoRebirthRunning = false

    getUnlockedRebirthOptions = function()
        local Rebirths = require(ReplicatedStorage.Shared.List.Rebirths)
        local Upgrades = require(ReplicatedStorage.Shared.List.Upgrades)
        local data = DataController.data
        local upgradeLevel = data.upgrades.rebirthButtons or 0
        local maxValue = Upgrades.rebirthButtons.upgrades[upgradeLevel].value
        local options = {}
        for index, amount in pairs(Rebirths) do
            if index <= maxValue then
                table.insert(options, {index = index, amount = amount, display = Functions.suffixes(amount) .. " Rebirths"})
            end
        end
        table.sort(options, function(a, b) return a.amount < b.amount end)
        return options
    end

    GetBestRebirthOption = function()
        local Rebirths = require(ReplicatedStorage.Shared.List.Rebirths)
        local Upgrades = require(ReplicatedStorage.Shared.List.Upgrades)
        local buttonUpgrade = Upgrades.rebirthButtons.upgrades[DataController.data.upgrades.rebirthButtons or 0]
        local unlockedOptions = {}
        for rebirthId, rebirthAmount in pairs(Rebirths) do
            if buttonUpgrade.value >= rebirthId then
                table.insert(unlockedOptions, {id = rebirthId, amount = rebirthAmount})
            end
        end
        table.sort(unlockedOptions, function(a, b) return a.amount > b.amount end)
        return #unlockedOptions > 0 and unlockedOptions[1].id or nil
    end

    updateRebirthDropdown = function()
        pcall(function()
            local options = getUnlockedRebirthOptions()
            rebirthOptions = options
            local dropdownValues = {"Max Unlocked"}
            for _, option in ipairs(options) do table.insert(dropdownValues, option.display) end
            if rebirthDropdown then rebirthDropdown:SetValues(dropdownValues) end
        end)
    end

    performRebirth = function()
        local rebirthIndex
        if isMaxUnlockedSelected then
            rebirthIndex = GetBestRebirthOption()
        elseif selectedRebirthIndex > 0 and selectedRebirthIndex <= #rebirthOptions then
            rebirthIndex = rebirthOptions[selectedRebirthIndex].index
        end
        if rebirthIndex then
            RebirthService:rebirth(rebirthIndex)
            return true
        end
        return false
    end

    rebirthDropdown = RebirthSection:Dropdown("RebirthDropdown", {  -- Remove 'local' here since it's already declared above
        Title = "Select Rebirth Amount", Values = {}, Searchable = true, Default = nil, Multi = false,
        Callback = function(selectedValue)
            if selectedValue == "Max Unlocked" then
                isMaxUnlockedSelected = true
                if #rebirthOptions > 0 then selectedRebirthIndex = #rebirthOptions end
            else
                isMaxUnlockedSelected = false
                for i, option in ipairs(rebirthOptions) do
                    if option.display == selectedValue then selectedRebirthIndex = i; break end
                end
            end
        end
    })

    local AutoRebirth = RebirthSection:Toggle("AutoRebirth", {
        Title = "Auto Rebirth", Default = false,
        Callback = function(Value)
            autoRebirthRunning = Value
            if Value then
                task.spawn(function()
                    while autoRebirthRunning do
                        pcall(performRebirth)
                        task.wait(0.2)
                    end
                end)
            end
        end
    })

    task.spawn(function()
        DataController:waitForData()
        task.wait(2)
        pcall(updateRebirthDropdown)
        while true do
            task.wait(5)
            pcall(updateRebirthDropdown)
        end
    end)

    local UpgradesSection = Tabs.Main:AddSection("Player Upgrades")
    local ActiveThreads = {}

    TerminateThread = function(index)
        if ActiveThreads[index] then
            ActiveThreads[index].IsRunning = false
            ActiveThreads[index] = nil
        end
    end

    CreateThread = function(index, fn)
        local thread = {IsRunning = true, Thread = fn}
        ActiveThreads[index] = thread
        task.spawn(function() thread.Thread(thread) end)
    end

    local upgradeValues = {}
    local UpgradesModule = require(ReplicatedStorage.Shared.List.Upgrades)
    for id, data in pairs(UpgradesModule) do
        table.insert(upgradeValues, {Name = id:sub(1,1):lower()..id:sub(2), Value = id})
    end

    local upgradesDropdown = UpgradesSection:Dropdown("UpgradesDropdown", {
        Title = "Select Upgrades", Values = upgradeValues, Multi = true, Searchable = true, Default = {},
        Displayer = function(item) return item.Name end
    })

    upgradesDropdown:OnChanged(function(value) end) -- Callback for potential future use

    UpgradesSection:Toggle("AutoBuyToggle", {
        Title = "Auto Buy Upgrades", Default = false,
        Callback = function(state)
            if not state then TerminateThread("AutoBuyUpgrades"); return end
            CreateThread("AutoBuyUpgrades", function(thread)
                DataController:waitForData()
                while thread.IsRunning and task.wait(0.5) do
                    local selected = upgradesDropdown.Value
                    for upgradeData, isSelected in pairs(selected) do
                        if isSelected then
                            if not thread.IsRunning then break end
                            local id = upgradeData.Value
                            local def = UpgradesModule[id]
                            if def and not (def.requiredMap and not DataController.data.maps[def.requiredMap]) then
                                local level = (DataController.data.upgrades[id] or 0) + 1
                                local costData = def.upgrades[level]
                                if costData and costData.cost <= DataController.data.gems then
                                    if UpgradeService:upgrade(id) then task.wait(0.1) end
                                end
                            end
                        end
                    end
                end
            end)
        end
    })

    local EggHatchingSection = Tabs.Eggs:AddSection("Auto Hatch")
    local EggsModule = require(ReplicatedStorage.Shared.List.Pets.Eggs)
    local EggUtils = require(ReplicatedStorage.Shared.Util.EggUtils)

    formatNumber = function(num)
        local suffixes={{1e18,"Qi"},{1e21,"Sx"},{1e24,"Sp"},{1e27,"Oc"},{1e30,"No"},{1e33,"Dc"},{1e36,"Ud"},{1e39,"Dd"},{1e42,"Td"},{1e45,"Qd"},{1e48,"Qid"},{1e51,"Sxd"},{1e54,"Spd"},{1e57,"Ocd"},{1e60,"Nd"},{1e63,"Vg"}}
        for i=#suffixes,1,-1 do local t,s=suffixes[i][1],suffixes[i][2] if num>=t then local v=num/t return string.format("%.2f%s",v,s):gsub("%.00","")end end
        if num>=1e15 then local v=num/1e15 return string.format("%.2fQa",v):gsub("%.00","")elseif num>=1e12 then local v=num/1e12 return string.format("%.2fT",v):gsub("%.00","")elseif num>=1e9 then local v=num/1e9 return string.format("%.2fB",v):gsub("%.00","")elseif num>=1e6 then local v=num/1e6 return string.format("%.2fM",v):gsub("%.00","")elseif num>=1e3 then local v=num/1e3 return string.format("%.2fK",v):gsub("%.00","")else return tostring(math.floor(num))end
    end

    local eggsTable, displayToEggName = {}, {}
    for eggName, eggData in pairs(EggsModule) do
        if typeof(eggData) == "table" and eggData.cost then
            table.insert(eggsTable, {name = eggName, cost = eggData.cost, currency = EggUtils.getCurrency(eggName) or "clicks"})
        end
    end
    table.sort(eggsTable, function(a, b) return a.cost < b.cost end)

    local eggOptions = {}
    for _, eggInfo in ipairs(eggsTable) do
        local displayName = eggInfo.name .. " - " .. formatNumber(eggInfo.cost) .. " " .. eggInfo.currency
        table.insert(eggOptions, displayName)
        displayToEggName[displayName] = eggInfo.name
    end

    selectedEgg = eggsTable[1] and eggsTable[1].name or "Basic"
    local defaultEgg = eggOptions[1] or "Basic"

    EggDropdown = EggHatchingSection:Dropdown("SelectEgg", {
        Title = "Select Egg", Values = eggOptions, Default = defaultEgg, Multi = false, Searchable = true,
        Callback = function(Value) 
            selectedEgg = displayToEggName[Value] or (Value:match("^(.-) %-") or Value)
        end
    })


    local hatchAmounts = {["1x"]=1, ["3x"]=3, ["Max"]=99}
    selectedAmount = hatchAmounts["Max"]
    HatchAmount = EggHatchingSection:Dropdown("SelectHatchAmount", {
        Title = "Select Hatch Amount", Values = {"1x", "3x", "Max"}, Multi = false, Default = "Max",
        Callback = function(Value) selectedAmount = hatchAmounts[Value] or 1 end
    })

    getLuckyIdForEggName = function(eggName)
        for _, eggModel in CollectionService:GetTagged("Egg") do
            if eggModel.Name == eggName then return eggModel:GetAttribute("luckyEggId") end
        end
        return nil
    end

    useLuckyEggs = false
    LuckyEgg = EggHatchingSection:Toggle("HatchLuckyEggs", {
        Title = "Use Lucky Eggs", Default = false,
        Callback = function(enabled) useLuckyEggs = enabled end
    })

    _G.SmartHatchDelay = 4.11
    task.spawn(function()
        local hatchTimeLabel = LocalPlayer.PlayerGui.MainUI.Menus.SettingsFrame.Main.List.Multipliers.HatchingSpeed.Main.Amount
        while true do
            local success, labelText = pcall(function() return hatchTimeLabel.Text end)
            if success and labelText then
                local numberString = string.match(labelText, "%d+%.?%d*")
                if numberString then _G.SmartHatchDelay = (tonumber(numberString) or 4.01) + 0.1 end
            end
            task.wait(5)
        end
    end)

    local AutoHatch = EggHatchingSection:Toggle("AutoHatch", {
        Title = "Auto Hatch Eggs", Default = false,
        Callback = function(Value)
            _G.AutoHatchEnabled = Value
            if Value then
                task.spawn(function()
                    while _G.AutoHatchEnabled do
                        local args = {selectedEgg, selectedAmount or 1}

                        if useLuckyEggs then
                            local anyAvailableLuckyId, _ = next(EggController._luckyEggs or {})
                            if anyAvailableLuckyId then
                                table.insert(args, {luckyEggId = anyAvailableLuckyId})
                            end
                        end

                        EggService.openEgg._re:FireServer(unpack(args))
                        
                        task.wait(_G.SmartHatchDelay)
                    end
                end)
            end
        end
    })

    HideAnimationToggle = EggHatchingSection:Toggle("HideHatchAnimation", {
        Title = "Hide Hatch Animation", Default = false,
        Callback = function(Value)
            local function overrideFunctions(shouldHide)
                if not HatchingController._originalFunctions and shouldHide then
                    HatchingController._originalFunctions = {
                        playEggAnimation = HatchingController.playEggAnimation, playHatchingAnimation = HatchingController.playHatchingAnimation,
                        animatePetIn = HatchingController.animatePetIn, animatePetOut = HatchingController.animatePetOut,
                        dropEggs = HatchingController.dropEggs, shakeEggs = HatchingController.shakeEggs,
                        scaleAndRemoveEggs = HatchingController.scaleAndRemoveEggs, playRevealSounds = HatchingController.playRevealSounds
                    }
                end
                local emptyFunc = function() return nil end
                for funcName, originalFunc in pairs(HatchingController._originalFunctions or {}) do
                    HatchingController[funcName] = shouldHide and emptyFunc or originalFunc
                end
            end
            overrideFunctions(Value)
        end
    })

    local TreeSection = Tabs.Tree:AddSection("Auto Break Trees")

    TreeSection:Paragraph("Tree",{
        Title = "Note",
        Content = "If you have auto hatch enabled, the speed in which you can break trees will massively decline. For best results, disable auto hatch while using the auto cut trees toggle.",
        TitleAlignment = "Middle",
        ContentAlignment = Enum.TextXAlignment.Left
    })

    getTreeTypes = function()
        local treeList = {}
        local Trees = require(ReplicatedStorage.Shared.List.Trees)

        for zoneName, zoneData in pairs(Trees) do
            if zoneName:lower() ~= "fall" and zoneData.trees and #zoneData.trees > 0 then
                local treeInfo = zoneData.trees[1]
                local hp = treeInfo.hp or 0
                local itemName = "Wood"
                
                if treeInfo and treeInfo.item then
                    local item = treeInfo.item
                    itemName = item.id or item.Name or item.name or (typeof(item.getId) == "function" and item:getId()) or (typeof(item.getName) == "function" and item:getName()) or (zoneName .. "Wood")
                    itemName = itemName:sub(1,1):upper() .. itemName:sub(2)
                end

                local displayName = zoneName:sub(1,1):upper() .. zoneName:sub(2) .. " (" .. itemName .. ")"
                table.insert(treeList, {
                    Name = displayName,
                    Value = zoneName,
                    HP = hp,
                    Wood = itemName
                })
            end
        end

        table.sort(treeList, function(a, b) return a.HP < b.HP end)
        return treeList
    end

    mapWoodToTreeWorld = function(woodName)
        if woodName:lower() == "wood" then
            return "spawn"
        end
        
        local Trees = require(ReplicatedStorage.Shared.List.Trees)
        
        for zoneName, zoneData in pairs(Trees) do
            if zoneData.trees and #zoneData.trees > 0 then
                local treeInfo = zoneData.trees[1]
                if treeInfo and treeInfo.item then
                    local item = treeInfo.item
                    local itemName = item.id or item.Name or item.name or (typeof(item.getId) == "function" and item:getId()) or (typeof(item.getName) == "function" and item:getName())
                    if itemName and itemName:lower() == woodName:lower() then return zoneName end
                end
            end
        end
        
        local woodMappings = {
            ["wood"] = "spawn",
        }
        return woodMappings[woodName:lower()] or "spawn"
    end

    getLumberId = function()
        local success, lumberId = pcall(debug.getupvalue, TreeController.autoDamageTree, 4)
        if success and type(lumberId) == "string" and #lumberId >= 32 then return lumberId end
        if TreeController._v_u_22 then return TreeController._v_u_22 end
        TreeController:getLumberId()
        task.wait(0.2)
        success, lumberId = pcall(debug.getupvalue, TreeController.autoDamageTree, 4)
        return (success and type(lumberId) == "string" and #lumberId >= 32) and lumberId or "70c6c87e76cd49409ce604d9cc0616ac"
    end

    selectedTrees = {}
    autoBreakRunning = false

    SelectTreesDropdown = TreeSection:Dropdown("SelectTrees", {
        Title = "Select Tree(s)",
        Description = "Choose which trees to automatically cut",
        Values = getTreeTypes(),
        Multi = true,
        Searchable = true,
        Default = {},
        Displayer = function(item) return item.Name end,
        Callback = function(value)
            selectedTrees = {}
            for treeType, isSelected in pairs(value) do
                if isSelected then table.insert(selectedTrees, treeType.Value) end
            end
        end
    })

    do
        local spawnTreeObject = nil
        for _, treeObject in ipairs(SelectTreesDropdown.Values) do
            if treeObject.Value == "spawn" then
                spawnTreeObject = treeObject
                break
            end
        end
        if spawnTreeObject then
            SelectTreesDropdown:SetValue({[spawnTreeObject] = true})
        end
    end

    getActiveTreesInGroup = function(groupId, data)
        local treesWithHealth = {}
        local mapsFolder = Workspace:FindFirstChild("Game") and Workspace.Game:FindFirstChild("Maps")
        if not mapsFolder then return treesWithHealth end

        local mapName
        for _, map in pairs(mapsFolder:GetChildren()) do
            if map.Name:lower() == groupId:lower() then
                mapName = map.Name
                break
            end
        end

        if not mapName then return treesWithHealth end
        local treesFolder = mapsFolder[mapName]:FindFirstChild("Trees")
        if not treesFolder then return treesWithHealth end

        for _, tree in pairs(treesFolder:GetChildren()) do
            local treeId = tree:GetAttribute("treeId")
            local hasModel = tree:FindFirstChildWhichIsA("Model") ~= nil

            if treeId and hasModel and 
            data.trees[groupId] and data.trees[groupId][treeId] and 
            data.trees[groupId][treeId].hp > 0 and 
            not data.trees[groupId][treeId].respawn then

                table.insert(treesWithHealth, {
                    treeId = treeId,
                    hp = data.trees[groupId][treeId].hp,
                    instance = tree,
                    groupId = groupId
                })
            end
        end

        table.sort(treesWithHealth, function(a, b) return a.hp < b.hp end)
        return treesWithHealth
    end

    AutoCutTreesToggle = TreeSection:Toggle("AutoCutTrees", {
        Title = "Auto Cut Trees",
        Description = "Self explanatory. Requires an axe to be equipped.",
        Default = false,
        Callback = function(Value)
            autoBreakRunning = Value

            if Value then
                local treeControllerThread = task.spawn(function()
                    if not game:IsLoaded() then game.Loaded:Wait() end

                    local function simulateClickOnClosestTree()
                        pcall(function()
                            local originalGetRay = TreeController.getRay
                            TreeController.getRay = function(self, _, _) return true end

                            local originalGetTreeFromRayResult = TreeController.getTreeFromRayResult
                            local targetTree = nil

                            TreeController.getTreeFromRayResult = function(_, _) return targetTree end

                            if not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                                TreeController.getRay = originalGetRay
                                TreeController.getTreeFromRayResult = originalGetTreeFromRayResult
                                return
                            end

                            local data = DataController:getData()
                            if not data or not data.trees then
                                TreeController.getRay = originalGetRay
                                TreeController.getTreeFromRayResult = originalGetTreeFromRayResult
                                return
                            end

                            local closestDistance = math.huge
                            local playerPosition = LocalPlayer.Character.HumanoidRootPart.Position

                            for _, groupId in ipairs(selectedTrees) do
                                if data.trees[groupId] then
                                    for _, tree in pairs(CollectionService:GetTagged("Tree")) do
                                        local model = tree:FindFirstChildWhichIsA("Model")
                                        if not model then continue end

                                        local treeGroupId = tree:GetAttribute("groupId")
                                        local treeId = tree:GetAttribute("treeId")

                                        if treeGroupId == groupId and treeId and 
                                        data.trees[groupId][treeId] and 
                                        data.trees[groupId][treeId].hp > 0 and
                                        not data.trees[groupId][treeId].respawn then

                                            local primaryPart = model.PrimaryPart or model:FindFirstChildWhichIsA("BasePart")
                                            if primaryPart then
                                                local distance = (primaryPart.Position - playerPosition).Magnitude
                                                if distance < closestDistance then
                                                    closestDistance = distance
                                                    targetTree = tree
                                                end
                                            end
                                        end
                                    end
                                end
                            end

                            if not targetTree then
                                TreeController.getRay = originalGetRay
                                TreeController.getTreeFromRayResult = originalGetTreeFromRayResult
                                return
                            end

                            TreeController:sendRayFromInput(0, 0)
                            TreeController.getRay = originalGetRay
                            TreeController.getTreeFromRayResult = originalGetTreeFromRayResult
                        end)
                    end

                    while autoBreakRunning do
                        simulateClickOnClosestTree()
                        task.wait(1)
                    end
                end)

                local teleportThread = task.spawn(function()
                    if not game:IsLoaded() then game.Loaded:Wait() end

                    local lumberId = getLumberId()
                    local currentGroup, currentId, lastTeleportTime = nil, nil, 0
                    math.randomseed(os.time() + os.clock() * 1000)

                    local data = DataController:getData()
                    while not data or not data.trees do
                        task.wait(0.5)
                        data = DataController:getData()
                    end

                    local function selectRandomTreeGroup()
                        data = DataController:getData()
                        if not data or not data.trees then return nil end

                        local validGroups = {}
                        for _, groupId in ipairs(selectedTrees) do
                            if data.trees[groupId] then
                                local hasActiveTrees = false
                                for treeId, treeData in pairs(data.trees[groupId]) do
                                    if treeData.hp > 0 and not treeData.respawn then
                                        hasActiveTrees = true
                                        break
                                    end
                                end
                                if hasActiveTrees then table.insert(validGroups, groupId) end
                            end
                        end

                        return #validGroups > 0 and validGroups[math.random(1, #validGroups)] or nil
                    end

                    local function findAndTeleportToRandomTree()
                        currentGroup = selectRandomTreeGroup()
                        if not currentGroup then return false end

                        if data.trees[currentGroup] then
                            local activeTrees = getActiveTreesInGroup(currentGroup, data)
                            if #activeTrees > 0 then
                                local randomTreeIndex = math.random(1, #activeTrees)
                                currentId = activeTrees[randomTreeIndex].treeId

                                local teleportSuccess = pcall(function()
                                    if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                                        local mapsFolder = Workspace:FindFirstChild("Game") and Workspace.Game:FindFirstChild("Maps")
                                        if mapsFolder then
                                            local mapName = nil
                                            for _, map in pairs(mapsFolder:GetChildren()) do
                                                if map.Name:lower() == currentGroup:lower() then
                                                    mapName = map.Name
                                                    break
                                                end
                                            end

                                            if mapName then
                                                local treesFolder = mapsFolder[mapName]:FindFirstChild("Trees")
                                                if treesFolder then
                                                    for _, tree in pairs(treesFolder:GetChildren()) do
                                                        if tree:GetAttribute("treeId") == currentId then
                                                            local model = tree:FindFirstChildWhichIsA("Model")
                                                            if model then
                                                                LocalPlayer.Character.HumanoidRootPart.CFrame = model:GetPivot() + Vector3.new(0, 5, 0)
                                                                lastTeleportTime = os.time()
                                                                return true
                                                            end
                                                            break
                                                        end
                                                    end
                                                end
                                            end
                                        end
                                    end
                                    return false
                                end)

                                if teleportSuccess then
                                    return true
                                else
                                    currentGroup, currentId = nil, nil
                                    return false
                                end
                            end
                        end

                        currentGroup, currentId = nil, nil
                        return false
                    end

                    while autoBreakRunning do
                        local shouldFindNewTree = not currentGroup or not currentId
                        
                        if not shouldFindNewTree then
                            data = DataController:getData()
                            if not data or not data.trees or 
                            not data.trees[currentGroup] or 
                            not data.trees[currentGroup][currentId] or
                            data.trees[currentGroup][currentId].hp <= 0 or 
                            data.trees[currentGroup][currentId].respawn then
                                shouldFindNewTree = true
                            end
                        end

                        if shouldFindNewTree then
                            findAndTeleportToRandomTree()
                        else
                            local currentTime = os.time()
                            if (currentTime - lastTeleportTime >= 3) then
                                pcall(function()
                                    if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                                        local mapsFolder = Workspace:FindFirstChild("Game") and Workspace.Game:FindFirstChild("Maps")
                                        if mapsFolder then
                                            local mapName = nil
                                            for _, map in pairs(mapsFolder:GetChildren()) do
                                                if map.Name:lower() == currentGroup:lower() then
                                                    mapName = map.Name
                                                    break
                                                end
                                            end

                                            if mapName then
                                                local treesFolder = mapsFolder[mapName]:FindFirstChild("Trees")
                                                if treesFolder then
                                                    for _, tree in pairs(treesFolder:GetChildren()) do
                                                        if tree:GetAttribute("treeId") == currentId then
                                                            local model = tree:FindFirstChildWhichIsA("Model")
                                                            if model then
                                                                LocalPlayer.Character.HumanoidRootPart.CFrame = model:GetPivot() + Vector3.new(0, 5, 0)
                                                                lastTeleportTime = currentTime
                                                                return
                                                            end
                                                            break
                                                        end
                                                    end
                                                end
                                            end
                                        end
                                    end
                                end)
                            end
                        end

                        if currentGroup and currentId and 
                        data.trees[currentGroup] and 
                        data.trees[currentGroup][currentId] and
                        data.trees[currentGroup][currentId].hp > 0 and 
                        not data.trees[currentGroup][currentId].respawn then
                            TreeService.damage2:Fire(currentGroup, currentId, lumberId)
                        end

                        task.wait(0.1)
                    end
                end)

                _G.TreeCuttingThreads = {
                    treeControllerThread = treeControllerThread,
                    teleportThread = teleportThread
                }

            else
                if _G.TreeCuttingThreads then
                    for name, thread in pairs(_G.TreeCuttingThreads) do
                        if thread then task.cancel(thread) end
                    end
                    _G.TreeCuttingThreads = nil
                end

                if TreeController._currentTree then
                    TreeController:cancelAutoDamageTree()
                end
            end
        end
    })

    lowercooldown = TreeSection:Toggle("RemoveCooldown", {
        Title = "Reduce Cutting Cooldown",
        Description = "Reduces the cooldown between tree hits (about 1.5x faster). Already built in with the auto trees toggle.",
        Default = false,
        Callback = function(Value)
            if Value then
                TreeController._debounce = {}
                TreeController._debounce = setmetatable({}, {
                    __index = function() return false end,
                    __newindex = function() end
                })
            else
                TreeController._debounce = {}
            end
        end
    })

    BypassStrength = TreeSection:Toggle("BypassTreeStrength", {
        Title = "Axe Strength Bypass",
        Description = "Allows you to cut any tree regardless of your current axe strength",
        Default = false,
        Callback = function(Value)
            if Value then
                if not TreeController._originalIsStrongEnough then
                    TreeController._originalIsStrongEnough = TreeController.isStrongEnough
                end
                TreeController.isStrongEnough = function() return true end
            else
                if TreeController._originalIsStrongEnough then
                    TreeController.isStrongEnough = TreeController._originalIsStrongEnough
                end
            end
        end
    })

    isAutoEquipAxeEnabled = false
    AutoEquip = TreeSection:Toggle("AutoEquipBestAxe", {
        Title = "Auto Equip Best Axe",
        Description = "Automatically equips the best axe you own.",
        Default = false,
        Callback = function(enabled)
            isAutoEquipAxeEnabled = enabled
            if enabled then
                task.spawn(function()
                    while isAutoEquipAxeEnabled do
                        pcall(function()
                            local ExclusiveItems = require(ReplicatedStorage.Shared.List.Items.Exclusive)
                            DataController:waitForData()
                            local playerData = DataController:getData()

                            local bestAxe, bestAxeIndex, bestInventoryIndex = nil, 0, nil
                            for inventoryIndex, itemData in pairs(playerData.inventory.exclusive) do
                                local itemObj = Util.itemUtils.createItemFromData(itemData)
                                local itemName = itemObj:getName()

                                if itemName:lower():find("axe") and not itemName:lower():find("pickaxe") then
                                    local axeData = ExclusiveItems[itemName]
                                    if axeData and axeData.index and axeData.index > bestAxeIndex then
                                        bestAxeIndex = axeData.index
                                        bestAxe = itemObj:getRealName()
                                        bestInventoryIndex = inventoryIndex
                                    end
                                end
                            end

                            if not bestAxe then return end

                            local isAxeEquipped = playerData.isAxeEquipped

                            if not isAxeEquipped then
                                InventoryService:useItem(bestInventoryIndex)
                            else
                                local currentAxe, currentAxeIndex, currentInventoryIndex = nil, 0, nil
                                for inventoryIndex, itemData in pairs(playerData.inventory.exclusive) do
                                    local itemObj = Util.itemUtils.createItemFromData(itemData)
                                    if itemObj:getName():lower():find("axe") and not itemObj:getName():lower():find("pickaxe") then
                                        currentAxe = itemObj:getRealName()
                                        currentAxeIndex = itemObj:directory()[itemObj:getName()].index
                                        currentInventoryIndex = inventoryIndex
                                        break
                                    end
                                end

                                if not (currentAxeIndex == bestAxeIndex and currentInventoryIndex == bestInventoryIndex) then
                                    InventoryService:useItem(bestInventoryIndex)
                                end
                            end
                        end)

                        for i = 1, 50 do
                            if not isAutoEquipAxeEnabled then break end
                            task.wait(0.1)
                        end
                    end
                end)
            end
        end
    })

    UpgradeAxe = Tabs.Tree:AddSection("Upgrade Axe")
    
    UpgradeAxe:Button({
    Title = "Enable Recommended Settings",
    Description = "Automatically enables: Auto Equip Best Axe, Reduce Cutting Cooldown, and Axe Strength Bypass",
    Callback = function()
        AutoEquip:SetValue(true)
        lowercooldown:SetValue(true) 
        BypassStrength:SetValue(true)
    end})

    local UpgradeStatusParagraph = UpgradeAxe:Paragraph("AxeUpgradeStatus", {
        Title = "Axe Upgrade",
        Content = "Loading upgrade info...",
        TitleAlignment = "Middle",
        ContentAlignment = Enum.TextXAlignment.Left
    })

    updateAxeUpgradeStatus = function()
        pcall(function()
            local ExclusiveItems = require(ReplicatedStorage.Shared.List.Items.Exclusive)
            local Items = require(ReplicatedStorage.Shared.Items)
            local AxesList = require(ReplicatedStorage.Shared.List.Axes)

            DataController:waitForData()
            local playerData = DataController:getData()

            local currentAxeIndex = 0
            for inventoryIndex, itemData in pairs(playerData.inventory.exclusive) do
                local itemObj = Util.itemUtils.createItemFromData(itemData)
                if itemObj:getName():lower():find("axe") and not itemObj:getName():lower():find("pickaxe") then
                    currentAxeIndex = itemObj:directory()[itemObj:getName()].index
                    break
                end
            end

            if currentAxeIndex == 0 then
                UpgradeStatusParagraph:SetValue("❌ No axe found in inventory!")
                return
            end

            local nextAxeIndex = currentAxeIndex + 1
            local nextAxe, nextAxeName = nil, nil

            for itemName, itemData in pairs(ExclusiveItems) do
                if itemName:lower():find("axe") and not itemName:lower():find("pickaxe") then
                    if itemData.index == nextAxeIndex then
                        nextAxe = Items.exclusive(itemName)
                        nextAxeName = itemName
                        break
                    end
                end
            end

            if not nextAxe then
                UpgradeStatusParagraph:SetValue("🎉 You have the maximum axe!")
                return
            end

            local axeRequirements = AxesList[nextAxeName]
            if not axeRequirements or not axeRequirements.required then
                UpgradeStatusParagraph:SetValue("❌ No requirements found for next axe!")
                return
            end

            local statusLines = {}
            table.insert(statusLines, "🎯 Next: " .. nextAxe:getRealName())
            table.insert(statusLines, "")
            table.insert(statusLines, "📋 Materials Needed:")

            local canUpgrade = true

            for i, requiredItem in ipairs(axeRequirements.required) do
                local itemName = requiredItem:getName()
                local requiredAmount = requiredItem:getAmount()

                local currentItem = Util.itemUtils.getItemFromName(playerData, itemName)
                local currentAmount = currentItem and currentItem:getAmount() or 0

                local hasEnough = requiredAmount <= currentAmount
                if not hasEnough then canUpgrade = false end

                local status = hasEnough and "✅" or "❌"
                local progress = string.format("%s/%s", 
                    Functions.comma(currentAmount), 
                    Functions.comma(requiredAmount))

                table.insert(statusLines, string.format("%s %s: %s", status, itemName, progress))
            end

            table.insert(statusLines, "")
            table.insert(statusLines, "🔨 Status: " .. (canUpgrade and "Ready to upgrade!" or "Need more materials"))

            UpgradeStatusParagraph:SetValue(table.concat(statusLines, "\n"))
        end)
    end
    
    task.spawn(function()
        while true do
            updateAxeUpgradeStatus()
            task.wait(5)
        end
    end)
    
    originalSelectedObjects = {}
    originalAutoCutState = false
    isAutoUpgradeEnabled = false
    treeToggleThread = nil

    manageTreeToggleCycle = function()
        while isAutoUpgradeEnabled do
            if autoBreakRunning then
                AutoCutTreesToggle:SetValue(false)
            end
            task.wait(1)
            
            if not autoBreakRunning then
                AutoCutTreesToggle:SetValue(true)
            end
            task.wait(0.5)
            
            if autoBreakRunning then
                AutoCutTreesToggle:SetValue(true)
            end
            task.wait(1)
            
            if not autoBreakRunning then
                AutoCutTreesToggle:SetValue(true)
            end
            
            task.wait(20)
        end
    end

    UpgradeAxe:Toggle("AutoUpgradeAxe", {
        Title = "Auto Upgrade Axe",
        Description = "Automatically upgrades your axe when materials are available\n\n⚠️ Recommended to enable:\n• Axe Strength Bypass\n• Auto Equip Best Axe",
        Default = false,
        Callback = function(enabled)
            if enabled then
                isAutoUpgradeEnabled = true

                originalSelectedObjects = {}
                for treeObject, isSelected in pairs(SelectTreesDropdown.Value) do
                    originalSelectedObjects[treeObject] = isSelected
                end

                originalAutoCutState = autoBreakRunning

                if treeToggleThread then task.cancel(treeToggleThread) end
                treeToggleThread = task.spawn(manageTreeToggleCycle)

                task.spawn(function()
                    while isAutoUpgradeEnabled do
                        pcall(function()
                            local ExclusiveItems = require(ReplicatedStorage.Shared.List.Items.Exclusive)
                            local Items = require(ReplicatedStorage.Shared.Items)
                            local AxesList = require(ReplicatedStorage.Shared.List.Axes)

                            DataController:waitForData()
                            local playerData = DataController:getData()

                            local currentAxeIndex = 0
                            for inventoryIndex, itemData in pairs(playerData.inventory.exclusive) do
                                local itemObj = Util.itemUtils.createItemFromData(itemData)
                                if itemObj:getName():lower():find("axe") and not itemObj:getName():lower():find("pickaxe") then
                                    currentAxeIndex = itemObj:directory()[itemObj:getName()].index
                                    break
                                end
                            end

                            if currentAxeIndex == 0 then return end

                            local nextAxeIndex = currentAxeIndex + 1
                            local nextAxeName = nil

                            for itemName, itemData in pairs(ExclusiveItems) do
                                if itemName:lower():find("axe") and not itemName:lower():find("pickaxe") then
                                    if itemData.index == nextAxeIndex then
                                        nextAxeName = itemName
                                        break
                                    end
                                end
                            end

                            if not nextAxeName then
                                isAutoUpgradeEnabled = false
                                return
                            end

                            local nextAxe = Items.exclusive(nextAxeName)
                            local axeRequirements = AxesList[nextAxeName]
                            if not axeRequirements or not axeRequirements.required then return end

                            local neededWoods = {}
                            local canUpgrade = true

                            for _, requiredItem in ipairs(axeRequirements.required) do
                                local itemName = requiredItem:getName()
                                local requiredAmount = requiredItem:getAmount()

                                local currentItem = Util.itemUtils.getItemFromName(playerData, itemName)
                                local currentAmount = currentItem and currentItem:getAmount() or 0

                                if currentAmount < requiredAmount then
                                    canUpgrade = false
                                    if itemName:lower():find("wood") then
                                        table.insert(neededWoods, itemName)
                                    end
                                end
                            end

                            if canUpgrade then
                                AxeService:upgradeAxe()
                                task.wait(2)
                            else
                                local neededTreeObjects = {}
                                for _, woodName in ipairs(neededWoods) do
                                    local treeWorld = mapWoodToTreeWorld(woodName)
                                    for _, treeObject in ipairs(SelectTreesDropdown.Values) do
                                        if treeObject.Value == treeWorld then
                                            neededTreeObjects[treeObject] = true
                                            break
                                        end
                                    end
                                end

                                SelectTreesDropdown:SetValue(neededTreeObjects)
                            end
                        end)
                        task.wait(5)
                    end
                end)
            else
                isAutoUpgradeEnabled = false
                
                if treeToggleThread then
                    task.cancel(treeToggleThread)
                    treeToggleThread = nil
                end
                
                SelectTreesDropdown:SetValue(originalSelectedObjects)

                if autoBreakRunning ~= originalAutoCutState then
                    AutoCutTreesToggle:SetValue(originalAutoCutState)
                end
            end
        end
    })

    getAllNonWoodRequirements = function()
        local AxesModule = require(ReplicatedStorage.Shared.List.Axes)
        local allRequirements = {}
        local requirementMap = {}
        
        for axeName, axeData in pairs(AxesModule) do
            if axeData.required then
                for _, item in ipairs(axeData.required) do
                    local amount = (item.getAmount and item:getAmount()) or item.Amount or 1
                    local itemName = (item.getName and item:getName()) or item.Name or "Unknown"

                    if not itemName:lower():find("wood") then
                        if axeName:lower():find("dungeon") and itemName:lower():find("pickaxe") then
                            itemName = "dungeonPotion"
                        elseif itemName:lower() == "dungeon" then
                            itemName = "dungeonPotions"
                        end
                        
                        if not requirementMap[itemName] or amount > requirementMap[itemName] then
                            requirementMap[itemName] = amount
                        end
                    end
                end
            end
        end
        
        for itemName, maxAmount in pairs(requirementMap) do
            table.insert(allRequirements, maxAmount .. "x " .. itemName)
        end
        
        if #allRequirements > 0 then
            return "Note you will need to own at least:\n" .. table.concat(allRequirements, ", ")
        else
            return "Note: Only wood is required for axe upgrades!"
        end
    end

    UpgradeAxe:Paragraph("NonWoodNote", {
        Title = "Additional Items",
        Content = getAllNonWoodRequirements(),
        TitleAlignment = "Middle",
        ContentAlignment = Enum.TextXAlignment.Left
    })

    local BuyFarmSection = Tabs.Farm:AddSection("Buy Farms")


    getAllFarms = function()
        local options, map = {}, {}
        pcall(function()
            local FarmsList = require(ReplicatedStorage.Shared.List.Farms)
            for farmId, farmInfo in pairs(FarmsList) do
                -- Exclude farmer and other non-purchasable items
                if not farmId:lower():find("1234") and 
                not farmInfo.isNotFarm and 
                farmInfo.price and 
                farmId ~= "farmer" then  -- Exclude farmer from auto-buy
                    local name = farmInfo.name or farmId
                    table.insert(options, name)
                    map[name] = farmId
                end
            end
            
            -- Don't add farmer to the options at all
        end)
        table.sort(options)
        return options, map
    end

    local farmOptions, farmIdMap = getAllFarms()

    local farmDropdown = BuyFarmSection:Dropdown("SelectFarms", {
        Title = "Select Farms to Buy",
        Values = farmOptions,
        Multi = true,
        Default = {}
    })

    local BuyFarm = BuyFarmSection:Toggle("AutoBuyFarms", {
        Title = "Auto Buy Selected Farms",
        Description = "Buy farms when you can afford them",
        Default = false,
        Callback = function(s) _G.AutoBuyFarms = s end
    })

    task.spawn(function()
        while task.wait(5) do -- Check every 5 seconds
            if not _G.AutoBuyFarms then continue end
            pcall(function()
                local playerData, FarmsList = DataController:getData(), require(ReplicatedStorage.Shared.List.Farms)
                if not playerData then return end
                
                -- Get selected farms, or use all farms if none selected
                local farmsToCheck = farmDropdown.Value or {}
                if not next(farmsToCheck) then
                    -- If no farms selected, check all available farms (excluding farmer)
                    for _, farmName in ipairs(farmOptions) do
                        farmsToCheck[farmName] = true
                    end
                end
                
                for farmName, selected in pairs(farmsToCheck) do
                    if selected then
                        local farmId = farmIdMap[farmName]
                        local farmInfo = FarmsList[farmId]
                        if farmId and farmInfo and 
                        (playerData.gems or 0) >= (farmInfo.price or 0) and 
                        not (playerData.farms and playerData.farms[farmId]) then
                            FarmService:buy(farmId)
                            task.wait(1) -- Wait 1 second after each purchase
                        end
                    end
                end
            end)
        end
    end)

    local AutoUpgradeFarmSection = Tabs.Farm:AddSection("Auto Upgrade Farms")

    getAllFarmsWithOptions = function()
        local options, farmMap = {}, {}
        pcall(function()
            local FarmsList, playerData = require(ReplicatedStorage.Shared.List.Farms), DataController:getData()
            if not playerData then return end

            local tempFarms = {}
            for id, info in pairs(FarmsList) do
                if not id:lower():find("1234") and not info.isNotFarm and info.upgrades then
                    local name = info.name or id
                    table.insert(tempFarms, { id = id, name = name })
                end
            end

            -- Always include farmer if upgrades exist
            if FarmsList.farmer and FarmsList.farmer.upgrades then
                table.insert(tempFarms, { id = "farmer", name = "farmer" })
            end

            table.sort(tempFarms, function(a, b) return a.name < b.name end)

            for _, data in ipairs(tempFarms) do
                table.insert(options, data.name)
                farmMap[data.name] = data.id
            end
        end)
        return options, farmMap
    end

    local allFarmOptions, allFarmIdMap = getAllFarmsWithOptions()

    local upgradeDropdown = AutoUpgradeFarmSection:Dropdown("SelectFarmsToUpgrade", {
        Title = "Select Farms to Upgrade",
        Values = allFarmOptions,
        Multi = true,
        Searchable = true,
        Default = {}
    })

    AutoUpgradeFarmSection:Toggle("AutoUpgradeFarms", {
        Title = "Auto Upgrade Selected Farms",
        Description = "Auto buys upgrades for the selected farms (must own).",
        Default = false,
        Callback = function(s) _G.AutoUpgradeFarms = s end
    })

    task.spawn(function()
        while task.wait(5) do -- Check affordability every 5 seconds
            if not (_G.AutoUpgradeFarms and next(upgradeDropdown.Value or {})) then continue end

            pcall(function()
                local selected = upgradeDropdown.Value
                local FarmsList = require(ReplicatedStorage.Shared.List.Farms)
                local playerData = DataController:getData()
                if not playerData then return end

                local upgradesToBuy = {}

                for farmName, isSelected in pairs(selected) do
                    if not isSelected then continue end

                    local farmId = allFarmIdMap[farmName]
                    local farmConfig = FarmsList[farmId]
                    if not (farmId and farmConfig and farmConfig.upgrades) then continue end
                    if not (playerData.farms and playerData.farms[farmId]) then continue end

                    local currentLevel = playerData.farms[farmId].stage or 0
                    local nextLevel = currentLevel + 1
                    local nextUpgradeInfo = farmConfig.upgrades[nextLevel]
                    if not nextUpgradeInfo then continue end

                    local upgradeCost = nextUpgradeInfo.price or 0
                    if (playerData.gems or 0) >= upgradeCost then
                        table.insert(upgradesToBuy, farmId)
                    end
                end

                -- Buy all upgrades we can afford, every 0.25s
                for _, farmId in ipairs(upgradesToBuy) do
                    FarmService:upgrade(farmId)
                    task.wait(0.25)
                end
            end)
        end
    end)

    local AutoClaimSection = Tabs.Farm:AddSection("Auto Claim")

    getAllFarmsForClaim = function()
        local options, farmMap = {}, {}
        pcall(function()
            local FarmsList = require(ReplicatedStorage.Shared.List.Farms)
            for farmId, farmInfo in pairs(FarmsList) do
                if not farmId:lower():find("farmer") and not farmInfo.isNotFarm then
                    local name = farmInfo.name or farmId
                    table.insert(options, name)
                    farmMap[name] = farmId
                end
            end
        end)
        table.sort(options)
        return options, farmMap
    end

    local claimFarmOptions, claimFarmIdMap = getAllFarmsForClaim()

    local claimDropdown = AutoClaimSection:Dropdown("SelectFarmsToClaim", {Title = "Select Farms to Claim", Values = claimFarmOptions, Multi = true, Default = {}})
    local AutoClaimFarm = AutoClaimSection:Toggle("AutoClaimFarms", {Title = "Auto Claim Farms" , Description = "Claim owned farms when they are ready.", Default = false, Callback = function(s) _G.AutoClaimFarms = s end})

    isFarmReady = function(farmId)
        local playerData = DataController:getData()
        if not playerData or not playerData.farms or not playerData.farms[farmId] then
            return false
        end
        
        local farmData = playerData.farms[farmId]
        local lastClaim = farmData.lastClaim or 0
        local cooldownDuration = Values.farmCooldown(LocalPlayer, playerData, farmId)
        local timeLeft = lastClaim + cooldownDuration - Knit.serverTimeNow
        
        return timeLeft <= 0
    end

    task.spawn(function()
        while task.wait(2) do
            if not _G.AutoClaimFarms or not next(claimDropdown.Value or {}) then continue end
            pcall(function()
                local playerData = DataController:getData()
                if not playerData then return end
                
                local Knit = require(game:GetService("ReplicatedStorage").Packages.Knit)
                local FarmService = Knit.GetService("FarmService")
                
                for farmName, selected in pairs(claimDropdown.Value) do
                    if selected then
                        local farmId = claimFarmIdMap[farmName]
                        
                        if farmId then
                            local isOwned = playerData.farms and playerData.farms[farmId]
                            if not isOwned then
                                continue
                            end
                            
                            if isFarmReady(farmId) then
                                local result = FarmService:claim(farmId)
                                
                                if result == "success" then
                                else
                                end
                                
                                task.wait(0.5)
                            end
                        end
                    end
                end
            end)
        end
    end)
    
    local CraftPetSection = Tabs.Pet:AddSection("Craft Pets")
    petDisplayToId = {}
    local PetStatusParagraph = CraftPetSection:AddParagraph("PetCraftStatus", { Title = "Selected Pet Status", Content = "Select a pet to see details." })
    
    getPlayerPetOptions = function()
        petDisplayToId = {}
        local petOptions, addedNames = {}, {}
        pcall(function()
            local Tiers = require(ReplicatedStorage.Shared.List.Pets.Tiers)
            local playerData = DataController:getData()
            if not (playerData and playerData.inventory and playerData.inventory.pet) then return end
            for petId, petRawData in pairs(playerData.inventory.pet) do
                local petObject = Util.itemUtils.createItemFromData(petRawData)
                if petObject then
                    local s, name = pcall(function() return petObject:getName() end)
                    if s then
                        local tierNum
                        local isShiny = (petRawData.sh == true)
                        pcall(function() tierNum = petObject:getTier() end)
                        local tierName = (tierNum and Tiers[tierNum]) and Tiers[tierNum].name or ""
                        if tierName == "Normal" then tierName = "" end
                        local nameParts = {}
                        if tierName ~= "" then table.insert(nameParts, tierName) end
                        if isShiny then table.insert(nameParts, "Shiny") end
                        table.insert(nameParts, name)
                        local displayName = table.concat(nameParts, " ")
                        if not addedNames[displayName] then
                            table.insert(petOptions, displayName)
                            petDisplayToId[displayName] = petId
                            addedNames[displayName] = true
                        end
                    end
                end
            end
        end)
        if #petOptions == 0 then return {"No pets found"} end
        table.sort(petOptions)
        return petOptions
    end

    updatePetStatusParagraph = function(selectedPets)
        if not selectedPets or next(selectedPets) == nil then PetStatusParagraph:SetContent("No pets selected."); return end
        local playerData = DataController:getData()
        if not (playerData and playerData.inventory and playerData.inventory.pet) then PetStatusParagraph:SetContent("Could not find pet inventory."); return end
        local contentLines = {}
        for displayName, isSelected in pairs(selectedPets) do
            if isSelected then
                local petId = petDisplayToId[displayName]
                if petId and playerData.inventory.pet[petId] then
                    local petObject = Util.itemUtils.createItemFromData(playerData.inventory.pet[petId])
                    if petObject then
                        local _, amount = pcall(function() return petObject:getAmount() end)
                        table.insert(contentLines, string.format("%s (Amount: %d) - ID: %s", displayName, amount or 0, petId))
                    end
                else table.insert(contentLines, string.format("%s (Amount: 0) - ID: %s", displayName, petId or "N/A")) end
            end
        end
        PetStatusParagraph:SetContent(#contentLines == 0 and "No pets selected." or table.concat(contentLines, "\n"))
    end

    local PetDropdown = CraftPetSection:AddDropdown("SelectPetToCraft", {
        Title = "Select Pet(s) to Craft", Values = getPlayerPetOptions(), Multi = true, Searchable = true, Default = {},
        Callback = function(value) updatePetStatusParagraph(value) end
    })

    CraftPetSection:AddButton({ Title = "Refresh Pet List", Callback = function() PetDropdown:SetValues(getPlayerPetOptions()); PetDropdown:SetValue({}); updatePetStatusParagraph({}) end })
    CraftPetSection:AddParagraph("CraftingNote", { Title = "Note", Content = "Crafting requires at least 5 of the same pet to create 1 of the next tier. You might need to rejoin after trying to craft a galaxy pet, and be aware that the pet needs to be released after the space update in order to craft to galaxy." })
    local CraftAmountInput = CraftPetSection:AddInput("CraftAmountInput", { Title = "Craft Amount", Default = "1", Numeric = true })

    CraftPetSection:AddButton({ Title = "Craft Specific Amount",
        Callback = function()
            local selectedPets, amount = PetDropdown.Value, tonumber(CraftAmountInput.Value) or 1
            if not next(selectedPets) then return end
            for displayName, isSelected in pairs(selectedPets) do
                if isSelected then
                    local petId = petDisplayToId[displayName]
                    if petId then pcall(function() PetService:craft({[1]=petId}, false, amount) end); task.wait(0.2) end
                end
            end
            task.wait(1); PetDropdown:SetValues(getPlayerPetOptions()); updatePetStatusParagraph(PetDropdown.Value)
        end
    })

    local CraftAllToggle = CraftPetSection:AddToggle("CraftAllToggle", { Title = "Craft All (Selected)", Default = false })
    CraftAllToggle:OnChanged(function()
        if CraftAllToggle.Value then
            task.spawn(function()
                while CraftAllToggle.Value do
                    local selectedPets, crafted = PetDropdown.Value, false
                    if next(selectedPets) then
                        for displayName, isSelected in pairs(selectedPets) do
                            if isSelected and CraftAllToggle.Value then
                                local petId = petDisplayToId[displayName]
                                if petId then pcall(function() PetService:craft({[1]=petId}, true, 1) end); crafted=true; task.wait(0.5) end
                            end
                        end
                    end
                    if crafted then task.wait(1); PetDropdown:SetValues(getPlayerPetOptions()) end
                    task.wait(1)
                end
            end)
        end
    end)

    task.spawn(function() while task.wait(3) do if PetDropdown and PetDropdown.Value and next(PetDropdown.Value) then pcall(updatePetStatusParagraph, PetDropdown.Value) end end end)

        
    local MapQuestSection = Tabs.Quest:AddSection("Map Quests")

    local MapQuestStatusParagraph = MapQuestSection:Paragraph("MapQuestStatus", {
        Title = "Map Quest Progress",
        Content = "Loading map quest status...",
        TitleAlignment = "Middle",
        ContentAlignment = Enum.TextXAlignment.Left
    })

    local updateMapQuestStatus = function()
        pcall(function()
            local Maps = require(ReplicatedStorage.Shared.List.Maps)
            DataController:waitForData()
            local playerData = DataController:getData()
            
            if not playerData then
                MapQuestStatusParagraph:SetValue("❌ Could not get player data")
                return
            end
            
            -- Find highest map number
            local highestMap = 0
            if playerData.maps then
                for mapNumber, _ in pairs(playerData.maps) do
                    if tonumber(mapNumber) and tonumber(mapNumber) > highestMap then
                        highestMap = tonumber(mapNumber)
                    end
                end
            end
            
            -- Next map to unlock
            local nextMapNumber = highestMap + 1
            local nextMap = Maps[nextMapNumber]
            
            local statusLines = {}
            table.insert(statusLines, string.format("🏆 Best Map Owned: %d", highestMap))
            
            if nextMap then
                table.insert(statusLines, string.format("🎯 Next Map: Map %d - %s", nextMapNumber, nextMap.name))
                table.insert(statusLines, "")
                
                if nextMap.quests then
                    table.insert(statusLines, "📋 Quest Progress:")
                    
                    for questIndex, questData in pairs(nextMap.quests) do
                        local questType = questData.quest
                        local required = questData.amount
                        local questName = questData.name
                        
                        -- Get progress from mapQuests
                        local currentProgress = playerData.mapQuests[questIndex] or 0
                        
                        -- Cap progress at required amount for display
                        local displayProgress = math.min(currentProgress, required)
                        
                        local isCompleted = currentProgress >= required
                        local status = isCompleted and "✅" or "❌"
                        local percentage = math.floor((displayProgress / required) * 100)
                        
                        -- Show quest info
                        local displayText = questType
                        if questName then
                            displayText = questType .. " (" .. questName .. ")"
                        end
                        
                        table.insert(statusLines, string.format("%s %s", status, displayText))
                        table.insert(statusLines, string.format("   %s/%s (%d%%)", 
                            Functions.suffixes(displayProgress),
                            Functions.suffixes(required),
                            percentage
                        ))
                    end
                end
            else
                table.insert(statusLines, "🎉 ALL MAPS UNLOCKED!")
            end
            
            MapQuestStatusParagraph:SetValue(table.concat(statusLines, "\n"))
        end)
    end

 
    -- Update map quest status every 5 seconds
    task.spawn(function()
        while true do
            updateMapQuestStatus()
            task.wait(5)
        end
    end)

    MapQuestSection:Toggle("AutoCompleteMapQuest", {
        Title = "Auto Complete Map Quest",
        Description = "Automatically completes map quests by setting up the appropriate automation",
        Default = false,
        Callback = function(enabled)
            -- Create a shared state variable that gets updated
            _G.MapQuestEnabled = enabled
            
            -- Store original states when enabling
            local originalStates = {
                autoClickEnabled = AutoClick.Value,
                autoRebirthEnabled = AutoRebirth.Value,
                selectedRebirthValue = rebirthDropdown.Value,
                selectedEggValue = EggDropdown.Value,
                selectedAmountValue = HatchAmount.Value,
                autoHatchEnabled = AutoHatch.Value,
                craftAllToggleState = CraftAllToggle.Value,
                selectedFarmsForClaim = claimDropdown.Value or {},
                autoClaimFarmsEnabled = AutoClaimFarm.Value,
                selectedTreesValue = SelectTreesDropdown.Value,
                autoCutTreesEnabled = AutoCutTreesToggle.Value,
                selectedPetsValue = PetDropdown.Value,
                autoBuyFarmsEnabled = BuyFarm.Value,
                selectedFarmsToBuy = farmDropdown.Value or {}
            }
            
            local function restoreOriginalStates()
                -- Restore all original settings immediately
                pcall(function()
                    if AutoClick then 
                        AutoClick:SetValue(originalStates.autoClickEnabled)
                    end
                    
                    if AutoRebirth then
                        AutoRebirth:SetValue(originalStates.autoRebirthEnabled)
                    end
                    
                    if rebirthDropdown then
                        rebirthDropdown:SetValue(originalStates.selectedRebirthValue)
                    end
                    
                    if EggDropdown then
                        EggDropdown:SetValue(originalStates.selectedEggValue)
                    end

                    if farmDropdown then
                        farmDropdown:SetValue(originalStates.selectedFarmsToBuy)
                    end
                    
                    if HatchAmount then
                        HatchAmount:SetValue(originalStates.selectedAmountValue)
                    end
                    
                    if AutoHatch then
                        AutoHatch:SetValue(originalStates.autoHatchEnabled)
                    end
                    
                    if CraftAllToggle then
                        CraftAllToggle:SetValue(originalStates.craftAllToggleState)
                    end
                    
                    if claimDropdown then
                        claimDropdown:SetValue(originalStates.selectedFarmsForClaim)
                    end
                    
                    if AutoClaimFarm then
                        AutoClaimFarm:SetValue(originalStates.autoClaimFarmsEnabled)
                    end
                    
                    if SelectTreesDropdown then
                        SelectTreesDropdown:SetValue(originalStates.selectedTreesValue)
                    end
                    
                    if AutoCutTreesToggle then
                        AutoCutTreesToggle:SetValue(originalStates.autoCutTreesEnabled)
                    end

                    if BuyFarm then
                        BuyFarm:SetValue(originalStates.autoBuyFarmsEnabled)
                    end
                    
                    if PetDropdown then
                        PetDropdown:SetValue(originalStates.selectedPetsValue)
                    end
                end)
            end
            
            if enabled then
                if AutoClick and not AutoClick.Value then
                    AutoClick:SetValue(true)
                end

                task.spawn(function()
                    while _G.MapQuestEnabled do -- Use global variable instead
                        local success = pcall(function()
                            -- Exit immediately if disabled
                            if not _G.MapQuestEnabled then
                                return
                            end
                            
                            local Maps = require(ReplicatedStorage.Shared.List.Maps)
                            local playerData = DataController:getData()
                            
                            if not playerData then return end
                            
                            -- Find highest map number
                            local highestMap = 0
                            if playerData.maps then
                                for mapNumber, _ in pairs(playerData.maps) do
                                    if tonumber(mapNumber) and tonumber(mapNumber) > highestMap then
                                        highestMap = tonumber(mapNumber)
                                    end
                                end
                            end
                            
                            -- Next map to unlock
                            local nextMapNumber = highestMap + 1
                            local nextMap = Maps[nextMapNumber]
                            
                            local allQuestsCompleted = true
                            
                            if nextMap and nextMap.quests then
                                for questIndex, questData in pairs(nextMap.quests) do
                                    -- Check if toggle was turned off at the start of each quest
                                    if not _G.MapQuestEnabled then
                                        return
                                    end
                                    
                                    local questType = questData.quest
                                    local required = questData.amount
                                    local questName = questData.name
                                    local currentProgress = playerData.mapQuests[questIndex] or 0
                                    
                                    -- Check if quest is completed
                                    if currentProgress >= required then
                                        continue -- Skip completed quests
                                    else
                                        allQuestsCompleted = false
                                    end
                                    
                                    -- Exit if disabled before processing quest
                                    if not _G.MapQuestEnabled then
                                        return
                                    end
                                    
                                    -- Handle different quest types
                                    if questType == "rebirths" then
                                        if rebirthDropdown then
                                            rebirthDropdown:SetValue("Max Unlocked")
                                        end
                                        
                                        if AutoRebirth and not AutoRebirth.Value then
                                            AutoRebirth:SetValue(true)
                                        end
                                        
                                        
                                    elseif questType == "openEgg" and questName then
                                        -- Use the exact egg name from questName
                                        local targetEggName = questName
                                        for _, eggOption in ipairs(eggOptions) do
                                            if eggOption:lower():find(targetEggName:lower()) then
                                                if EggDropdown then
                                                    EggDropdown:SetValue(eggOption)
                                                end
                                                break
                                            end
                                        end
                                        
                                        -- Set hatch amount to Max
                                        if HatchAmount then
                                            HatchAmount:SetValue("Max")
                                        end
                                        
                                        -- Enable auto hatch
                                        if AutoHatch and not AutoHatch.Value then
                                            AutoHatch:SetValue(true)
                                        end


                                    elseif questType == "craftAnyGalaxyPets" then
                                        -- Use the egg from the zone BEFORE the current target zone
                                        local previousMapNumber = nextMapNumber - 1
                                        local previousMap = Maps[previousMapNumber]
                                        local previousWorldEggName = nil
                                        
                                        if previousMap and previousMap.name then
                                            previousWorldEggName = previousMap.name
                                        else
                                            -- Fallback to current world if no previous map
                                            previousWorldEggName = nextMap.name
                                        end
                                        
                                        -- Select the appropriate egg for the previous world
                                        for _, eggOption in ipairs(eggOptions) do
                                            if eggOption:lower():find(previousWorldEggName:lower()) then
                                                if EggDropdown then
                                                    EggDropdown:SetValue(eggOption)
                                                end
                                                break
                                            end
                                        end
                                        
                                        -- Enable auto hatch to get pets for crafting
                                        if AutoHatch and not AutoHatch.Value then
                                            if HatchAmount then
                                                HatchAmount:SetValue("Max")
                                            end
                                            AutoHatch:SetValue(true)
                                        end
                                        
                                        -- Find pets from the previous world egg for crafting
                                        task.wait(2) -- Wait for pets to be hatched
                                        PetDropdown:SetValues(getPlayerPetOptions())
                                        local playerPetOptions = getPlayerPetOptions()
                                        local galaxyCraftablePets = {}
                                        
                                        -- Get pets specifically from the previous world egg
                                        local Eggs = require(ReplicatedStorage.Shared.List.Pets.Eggs)
                                        local previousEggData = Eggs[previousWorldEggName]
                                        local previousWorldPetNames = {}
                                        
                                        if previousEggData and previousEggData.pets then
                                            for petName, _ in pairs(previousEggData.pets) do
                                                table.insert(previousWorldPetNames, petName)
                                            end
                                        end
                                        
                                        -- Find player pets that match previous world pets
                                        for _, displayName in ipairs(playerPetOptions) do
                                            for _, worldPetName in ipairs(previousWorldPetNames) do
                                                if displayName:find(worldPetName) then
                                                    galaxyCraftablePets[displayName] = true
                                                    break
                                                end
                                            end
                                        end

                                        -- Also select toxic pets from Comet+ worlds with >0.01% chance
                                        local toxicPetNames = {}
                                        if playerData.maps then
                                            for mapNumber, _ in pairs(playerData.maps) do
                                                local mapNum = tonumber(mapNumber)
                                                if mapNum and mapNum >= 17 then -- Moon is 17
                                                    local mapData = Maps[mapNum]
                                                    if mapData and mapData.name then
                                                        local worldEggData = Eggs[mapData.name]
                                                        if worldEggData and worldEggData.pets then
                                                            for petName, chance in pairs(worldEggData.pets) do
                                                                if chance > 0.01 then -- Only pets with >0.01% chance
                                                                    table.insert(toxicPetNames, petName)
                                                                end
                                                            end
                                                        end
                                                    end
                                                end
                                            end
                                        end

                                        -- Find player pets that match toxic pet names
                                        for _, displayName in ipairs(playerPetOptions) do
                                            for _, toxicPetName in ipairs(toxicPetNames) do
                                                if displayName:find("Toxic") and displayName:find(toxicPetName) then
                                                    galaxyCraftablePets[displayName] = true
                                                    break
                                                end
                                            end
                                        end
                                        
                                        if next(galaxyCraftablePets) and PetDropdown then
                                            PetDropdown:SetValue(galaxyCraftablePets)
                                            
                                            -- Enable craft all toggle
                                            if CraftAllToggle and not CraftAllToggle.Value then
                                                CraftAllToggle:SetValue(true)
                                            end
                                        end
                                        
                                    elseif questType == "hatchPet" and questName then
                                        -- For hatchPet quests, use the world name from the PREVIOUS map
                                        local previousMapNumber = nextMapNumber - 1
                                        local previousMap = Maps[previousMapNumber]
                                        local worldName = previousMap and previousMap.name or "Spawn"
                                        
                                        -- Find the egg for the previous world
                                        for _, eggOption in ipairs(eggOptions) do
                                            if eggOption:lower():find(worldName:lower()) then
                                                if EggDropdown then
                                                    EggDropdown:SetValue(eggOption)
                                                end
                                                break
                                            end
                                        end
                                        
                                        -- Set hatch amount to Max and enable auto hatch
                                        if HatchAmount then
                                            HatchAmount:SetValue("Max")
                                        end
                                        
                                        if AutoHatch and not AutoHatch.Value then
                                            AutoHatch:SetValue(true)
                                        end
             
                                    elseif questType == "useAuraDice" then
                                        -- Find the aura dice the player has the most of
                                        local bestDiceId = nil
                                        local maxAmount = 0
                                        
                                        if playerData.inventory and playerData.inventory.auraDice then
                                            for itemId, itemData in pairs(playerData.inventory.auraDice) do
                                                local amount = itemData.am or 0
                                                if amount > maxAmount then
                                                    maxAmount = amount
                                                    bestDiceId = itemData.nm or itemId
                                                end
                                            end
                                        end
                                        
                                        if bestDiceId and maxAmount > 0 then
                                            -- Use the dice
                                            pcall(function()
                                                AuraService:roll(bestDiceId)
                                            end)
                                            task.wait(2) -- Wait between rolls
                                        end
                                        
                                    elseif questType == "collectFruits" then
                                        -- Set rebirth to Max Unlocked and enable auto rebirth
                                        if rebirthDropdown then
                                            rebirthDropdown:SetValue("Max Unlocked")
                                        end
                                        
                                        if AutoRebirth and not AutoRebirth.Value then
                                            AutoRebirth:SetValue(true)
                                        end
                                        
                                        -- Select all farms for buying and enable auto buy
                                        if farmDropdown then
                                            local allFarms = {}
                                            for _, farmName in ipairs(farmOptions) do
                                                allFarms[farmName] = true
                                            end
                                            farmDropdown:SetValue(allFarms)

                                            if BuyFarm and not BuyFarm.Value then
                                                BuyFarm:SetValue(true)
                                            end
                                        end
                                        
                                        -- Select all farms in auto claim section and enable toggle
                                        if claimDropdown then
                                            local allClaimFarms = {}
                                            for _, farmName in ipairs(claimFarmOptions) do
                                                allClaimFarms[farmName] = true
                                            end
                                            claimDropdown:SetValue(allClaimFarms)
                                            
                                            -- Enable auto claim farms
                                            if AutoClaimFarm and not AutoClaimFarm.Value then
                                                AutoClaimFarm:SetValue(true)
                                            end
                                        end
                                    
                                    elseif questType == "building" and questName then
                                        -- Build Wooden Bridge for building quests
                                        if questName:lower():find("bridge") or questName:lower():find("wooden") then
                                            local Knit = require(game:GetService("ReplicatedStorage").Packages.Knit)
                                            Knit.GetService("BuildingService"):build("woodenBridge")
                                        end

                                    elseif questType == "usePotions" then
                                        -- Find potion with highest amount (non-mega)
                                        local bestPotionId = nil
                                        local maxAmount = 0
                                        
                                        if playerData.inventory and playerData.inventory.potion then
                                            for itemId, itemData in pairs(playerData.inventory.potion) do
                                                local amount = itemData.am or 0
                                                local name = itemData.nm or ""
                                                -- Exclude mega potions
                                                if amount > maxAmount and not name:lower():find("mega") then
                                                    maxAmount = amount
                                                    bestPotionId = itemId
                                                end
                                            end
                                        end
                                        
                                        if bestPotionId and maxAmount > 0 then
                                            -- Calculate how many potions needed to complete quest
                                            local potionsNeeded = required - currentProgress
                                            potionsNeeded = math.min(potionsNeeded, maxAmount) -- Don't use more than available
                                            
                                            if potionsNeeded > 0 then
                                                pcall(function()
                                                    local Knit = require(ReplicatedStorage.Packages.Knit)
                                                    Knit.GetService("InventoryService"):useItem(bestPotionId, {use = potionsNeeded})
                                                end)
                                                task.wait(2)
                                            end
                                        end
                                        
                                    elseif questType == "useMegaPotions" then
                                        -- Find mega potion with highest amount
                                        local bestMegaPotionId = nil
                                        local maxAmount = 0
                                        
                                        if playerData.inventory and playerData.inventory.potion then
                                            for itemId, itemData in pairs(playerData.inventory.potion) do
                                                local amount = itemData.am or 0
                                                local name = itemData.nm or ""
                                                -- Only mega potions
                                                if amount > maxAmount and name:lower():find("mega") then
                                                    maxAmount = amount
                                                    bestMegaPotionId = itemId
                                                end
                                            end
                                        end
                                        
                                        if bestMegaPotionId and maxAmount > 0 then
                                            -- Calculate how many mega potions needed to complete quest
                                            local megaPotionsNeeded = required - currentProgress
                                            megaPotionsNeeded = math.min(megaPotionsNeeded, maxAmount) -- Don't use more than available
                                            
                                            if megaPotionsNeeded > 0 then
                                                pcall(function()
                                                    local Knit = require(ReplicatedStorage.Packages.Knit)
                                                    Knit.GetService("InventoryService"):useItem(bestMegaPotionId, {use = megaPotionsNeeded})
                                                end)
                                                task.wait(2)
                                            end
                                        end
                                    end
                                    
                                    -- Check again after each quest processing
                                    if not _G.MapQuestEnabled then
                                        return
                                    end
                                end
                            else
                                allQuestsCompleted = true
                            end
                            
                            -- If all quests are completed, restore original states
                            if allQuestsCompleted then
                                restoreOriginalStates()
                                _G.MapQuestEnabled = false -- Stop the loop
                                return
                            end
                        end)
                        
                        if not success then
                        end
                        
                        -- Final check before next iteration
                        if not _G.MapQuestEnabled then
                            break
                        end
                        
                        task.wait(3) -- Check every 3 seconds
                    end
                    
                    -- Final cleanup when loop ends (either disabled or completed)
                    restoreOriginalStates()
                end)
            else
                -- Immediately set global state and restore when toggle is turned off
                _G.MapQuestEnabled = false
                restoreOriginalStates()
            end
        end
    })

    local MapQuestNone = MapQuestSection:Paragraph("MapQuestNone", {
        Title = "Note",
        Content = "For the build quest in the kingdom world, the bridge will be built, but this script won't source the resources. Make sure you have at least 3 ancient ticks, 3 fire aura dice, 5 grapes, and 5 apples.",
        TitleAlignment = "Middle",
        ContentAlignment = Enum.TextXAlignment.Left
    })

    local AngelQuestSection = Tabs.Quest:AddSection("Angel Quests")

    angelQuestEnabled = false

    local AngelQuestStatusParagraph = AngelQuestSection:Paragraph("AngelQuestStatus", {
        Title = "Angel Quest Status",
        Content = "Loading quest status...",
        TitleAlignment = "Middle",
        ContentAlignment = Enum.TextXAlignment.Left
    })

    updateAngelQuestStatus = function()
        pcall(function()
            local AngelQuestsList = require(ReplicatedStorage.Shared.List.AngelQuests)
            DataController:waitForData()
            local playerData = DataController:getData()
            
            local currentTier = playerData.angelQuestTier or 1
            local currentProgress = playerData.angelQuestProgress or 0
            local totalTiers = #AngelQuestsList
            
            if currentTier > totalTiers then
                AngelQuestStatusParagraph:SetValue(string.format("🎉 Completed all %d Angel Quests!", totalTiers))
            else
                local questInfo = AngelQuestsList[currentTier]
                if questInfo then
                    local requiredAmount = questInfo.quest.amount
                    local formattedQuestText = questInfo.text:format(requiredAmount)
                    
                    local statusText = string.format(
                        "📋 Tier: %d/%d\n🎯 Quest: %s\n📊 Progress: %d/%d",
                        currentTier, totalTiers, formattedQuestText, currentProgress, requiredAmount
                    )
                    AngelQuestStatusParagraph:SetValue(statusText)
                else
                    AngelQuestStatusParagraph:SetValue(string.format("❌ Unable to read quest for Tier %d", currentTier))
                end
            end
        end)
    end

    getAllAuraDice = function()
        local options, diceMap = {}, {}
        pcall(function()
            local AuraDices = require(ReplicatedStorage.Shared.List.Items.AuraDices)
            for diceId, diceData in pairs(AuraDices) do
                local displayName = diceData.name
                table.insert(options, displayName)
                diceMap[displayName] = diceId
            end
        end)
        table.sort(options)
        return options, diceMap
    end

    local diceOptions, diceIdMap = getAllAuraDice()

    allowedDiceDropdown = AngelQuestSection:Dropdown("AllowedDice", {
        Title = "Allowed Dice",
        Description = "Select which dice to use for aura quests (if none selected, uses any owned dice)",
        Values = diceOptions,
        Multi = true,
        Searchable = true,
        Default = {}
    })


    getCurrentQuestType = function()
        local success, result = pcall(function()
            local AngelQuestsList = require(ReplicatedStorage.Shared.List.AngelQuests)
            DataController:waitForData()
            local playerData = DataController:getData()
            
            if not playerData then 
                return nil 
            end
            
            local currentTier = playerData.angelQuestTier or 1
            
            if currentTier <= #AngelQuestsList then
                local questData = AngelQuestsList[currentTier]
                return questData and questData.quest or nil
            else
                return nil
            end
        end)
        
        if success then
            return result
        else
            return nil
        end
    end


    findBestPotion = function()
        local playerData = DataController:getData()
        if not playerData or not playerData.inventory or not playerData.inventory.exclusive then
            return nil
        end
        
        local bestPotion = nil
        local highestAmount = 0
        
        for itemId, itemData in pairs(playerData.inventory.exclusive) do
            if itemData.nm and itemData.nm:lower():find("potion") and itemData.am and itemData.am > highestAmount then
                highestAmount = itemData.am
                bestPotion = itemId
            end
        end
        
        return bestPotion
    end

    getAvailableAuraDice = function()
        local playerData = DataController:getData()
        if not playerData then
            return {}
        end
        
        local selectedDice = allowedDiceDropdown.Value or {}
        local availableDice = {}
        
        if next(selectedDice) == nil then
            local AuraDices = require(ReplicatedStorage.Shared.List.Items.AuraDices)
            
            for diceId, diceData in pairs(AuraDices) do
                local item = Util.itemUtils.getItemFromName(playerData, diceId)
                if item and item:getAmount() > 0 then
                    table.insert(availableDice, diceId)
                end
            end
        else
            for diceName, isSelected in pairs(selectedDice) do
                if isSelected then
                    local diceId = diceIdMap[diceName]
                    local item = Util.itemUtils.getItemFromName(playerData, diceId)
                    if item and item:getAmount() > 0 then
                        table.insert(availableDice, diceId)
                    end
                end
            end
        end
        
        return availableDice
    end

    setupForQuestType = function(questType)
        if not questType then 
            return 
        end
        
        local questName = questType.quest
        
        if questName:lower():find("egg") or questName:lower():find("hatch") then
            
            local heavenEggFound = false
            
            for i, eggOption in ipairs(eggOptions) do
                if eggOption:lower():find("heaven") then
                    EggDropdown:SetValue(eggOption)
                    selectedEgg = displayToEggName[eggOption] or "Heaven"
                    heavenEggFound = true
                    break
                end
            end
            
            if not heavenEggFound then
            end
            
            HatchAmount:SetValue("Max")
            selectedAmount = hatchAmounts["Max"]
            
            if not _G.AutoHatchEnabled then
                AutoHatch:SetValue(true)
            else
            end
        end
        
        if questName == "destroyTree" then
            AutoEquip:SetValue(true)
            local neededTrees = {}
            for _, treeObject in ipairs(SelectTreesDropdown.Values) do
                local treeName = treeObject.Value:lower()
                if treeName == "spawn" or treeName == "desert" or treeName == "nuclear" then
                    neededTrees[treeObject] = true
                end
            end
            SelectTreesDropdown:SetValue(neededTrees)
            selectedTrees = {}
            for treeType, isSelected in pairs(neededTrees) do
                if isSelected then table.insert(selectedTrees, treeType.Value) end
            end
            if not autoBreakRunning then
                AutoCutTreesToggle:SetValue(true)
            else
            end
        end
        
        if questName == "craftRing" then
            task.spawn(function()
                while angelQuestEnabled do
                    pcall(function()
                        local Knit = require(ReplicatedStorage.Packages.Knit)
                        Knit.GetService("RingService"):craftRing("basicRing", 1)
                    end)
                    task.wait(5)
                end
            end)
        end
        
        if questName == "usePotions" then
            task.spawn(function()
                while angelQuestEnabled do
                    local potionId = findBestPotion()
                    if potionId then
                        pcall(function()
                            local Knit = require(ReplicatedStorage.Packages.Knit)
                            Knit.GetService("InventoryService"):useItem(potionId, {use = 1})
                        end)
                    else
                    end
                    task.wait(2)
                end
            end)
        end

        if questName == "useAuraDice" or questName == "rollOneInAura" then
            task.spawn(function()
                while angelQuestEnabled do
                    local currentQuest = getCurrentQuestType()
                    if not currentQuest or (currentQuest.quest ~= "useAuraDice" and currentQuest.quest ~= "rollOneInAura") then
                        break 
                    end
                    
                    local availableDice = getAvailableAuraDice()
                    if #availableDice > 0 then
                        local randomDice = availableDice[math.random(1, #availableDice)]
                        pcall(function()
                            AuraService:roll(randomDice)
                        end)
                    else
                    end
                    task.wait(2)
                end
            end)
        end
    end

    storeOriginalSettings = function()
        originalEggSelection = selectedEgg
        originalHatchAmount = selectedAmount
        
        originalAutoHatchState = AutoHatch.Value

        originalTreeSelection = {}
        for treeObject, isSelected in pairs(SelectTreesDropdown.Value) do
            originalTreeSelection[treeObject] = isSelected
        end
        originalAutoCutState = autoBreakRunning
    end

    restoreOriginalSettings = function()
        if originalEggSelection then
            for _, eggOption in ipairs(eggOptions) do
                if eggOption:find(originalEggSelection) then
                    EggDropdown:SetValue(eggOption)
                    selectedEgg = displayToEggName[eggOption] or originalEggSelection
                    break
                end
            end
        end
        
        if originalHatchAmount then
            local amountText = originalHatchAmount == 1 and "1x" or originalHatchAmount == 3 and "3x" or "Max"
            HatchAmount:SetValue(amountText)
            selectedAmount = originalHatchAmount
        end
        
        if not originalAutoHatchState and _G.AutoHatchEnabled then
            AutoHatch:SetValue(false)
        end
        
        if originalTreeSelection then
            SelectTreesDropdown:SetValue(originalTreeSelection)
            
            selectedTrees = {}
            for treeType, isSelected in pairs(originalTreeSelection) do
                if isSelected then table.insert(selectedTrees, treeType.Value) end
            end
        end
        
        if autoBreakRunning ~= originalAutoCutState then
            AutoCutTreesToggle:SetValue(originalAutoCutState)
        end
    end

    angelQuestToggle = AngelQuestSection:Toggle("AutoCompleteAngelQuest", {
        Title = "Auto Complete Angel Quest",
        Description = "Automatically completes the angel quests.",
        Default = false,
        Callback = function(enabled)
            angelQuestEnabled = enabled
            
            if enabled then
                storeOriginalSettings()
                
                task.spawn(function()
                    task.wait(2)
                    
                    while angelQuestEnabled do
                        local currentQuest = getCurrentQuestType()
                        
                        if currentQuest then
                            setupForQuestType(currentQuest)
                        else
                        end
                        
                        pcall(function()
                            local AngelQuestsList = require(ReplicatedStorage.Shared.List.AngelQuests)
                            DataController:waitForData()
                            local playerData = DataController:getData()
                            
                            local currentTier = playerData.angelQuestTier or 1
                            local currentProgress = playerData.angelQuestProgress or 0
                            
                            if currentTier <= #AngelQuestsList then
                                local questInfo = AngelQuestsList[currentTier]
                                if questInfo then
                                    local requiredAmount = questInfo.quest.amount
                                    
                                    if currentProgress >= requiredAmount then
                                        local Knit = require(ReplicatedStorage.Packages.Knit)
                                        Knit.GetService("QuestService"):claimAngelQuest()
                                        restoreOriginalSettings()
                                        task.wait(2)
                                    end
                                end
                            end
                        end)
                        
                        updateAngelQuestStatus()
                        task.wait(1)
                    end
                end)
            else
                restoreOriginalSettings()
            end
        end
    })

    task.spawn(function()
        while true do
            updateAngelQuestStatus()
            task.wait(5)
        end
    end)

    
    local machines = Tabs.Machine:AddSection("Machine Script")
    
    machines:Button({
        Title = "Load Script",
        Description = "Sorry for the separate loadstring! Having such a large script was causing me to run out of local uses and creating lag issues.",
        Callback = function()
            loadstring(game:HttpGet("https://raw.githubusercontent.com/bigbeanscripts/RCU-machine/refs/heads/main/RCU."))()
        end
    })


    -- Function to check if player is in dungeon
    local function isInDungeon()
        local success, result = pcall(function()
            local DungeonController = Knit.GetController("DungeonController")
            return DungeonController:isInDungeon()
        end)
        return success and result or false
    end

    AutoCritDamageSection = Tabs.Dunegon:AddSection("Auto Crit/Damage")

    local autoCriticalTapEnabled = false
    local inDungeon = false

    -- Check dungeon status every 5 seconds
    task.spawn(function()
        while true do
            if autoCriticalTapEnabled then
                inDungeon = isInDungeon()
            end
            task.wait(5)
        end
    end)

    AutoCritDamageSection:Toggle("AutoCriticalTap", {
        Title = "Auto Critical Tap",
        Description = "You will always deal 1000x damage. Incredibly overpowered.",
        Default = false,
        Callback = function(Value)
            autoCriticalTapEnabled = Value
            if Value then
                inDungeon = isInDungeon() 
                task.spawn(function()
                    while autoCriticalTapEnabled do
                        if inDungeon then
                            pcall(function()
                                DungeonService.damage._re:FireServer()
                                DungeonService.criticalTap._re:FireServer()
                            end)
                        end
                        task.wait(0.15)
                    end
                end)
            end
        end
    })

    AutoPickupPowerups = Tabs.Dunegon:AddSection("Auto Use Powerups")

    AutoPickupPowerups:Toggle("AutoPickupPowerups", {
        Title = "Auto Pickup Powerups",
        Description = "Automatically picks up all available dungeon powerups.",
        Default = false,
        Callback = function(Value)
            autoPickupEnabled = Value
            if Value then
                task.spawn(function()
                    local Powerups = require(ReplicatedStorage.Shared.List.Dungeon.Powerups)

                    -- Precompute lowercase module keys for case-insensitive comparison
                    local moduleKeys = {}
                    for key, _ in pairs(Powerups) do
                        moduleKeys[key:lower()] = key
                    end

                    while autoPickupEnabled do
                        if isInDungeon() then
                            local character = LocalPlayer.Character
                            local rootPart = character and character:FindFirstChild("HumanoidRootPart")

                            if rootPart then
                                local debrisFolder = workspace:FindFirstChild("Debris")
                                if debrisFolder then
                                    for _, child in ipairs(debrisFolder:GetChildren()) do
                                        local childKey = child.Name:gsub("%s",""):lower()
                                        if moduleKeys[childKey] then
                                            local touchFired = false
                                            -- Loop through all parts of this powerup to find TouchInterest
                                            for _, part in ipairs(child:GetChildren()) do
                                                local touch = part:FindFirstChild("TouchInterest")
                                                if touch then
                                                    pcall(function()
                                                        firetouchinterest(rootPart, part, 0)
                                                        firetouchinterest(rootPart, part, 1)
                                                    end)
                                                    touchFired = true
                                                    task.wait(0.25)
                                                    break -- fire only once per powerup
                                                end
                                            end
                                            -- If TouchInterest is directly on the parent
                                            if not touchFired then
                                                local touch = child:FindFirstChild("TouchInterest")
                                                if touch then
                                                    pcall(function()
                                                        firetouchinterest(rootPart, child, 0)
                                                        firetouchinterest(rootPart, child, 1)
                                                    end)
                                                    task.wait(0.25)
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                        end
                        task.wait(3)
                    end
                end)
            end
        end
    })

    EquipBest = Tabs.Dunegon:AddSection("Equip Best Pets")
        
    local equipBestPetsEnabled = false

    EquipBest:Toggle("EquipBestDungeonPets", {
        Title = "Equip Best Dungeon Pets",
        Description = "Automatically equips the best dungeon pets and removes weaker ones. Checks every 5 seconds.",
        Default = false,
        Callback = function(Value)
            equipBestPetsEnabled = Value
            if Value then
                task.spawn(function()
                    while equipBestPetsEnabled do
                        pcall(function()
                            local itemUtils = require(ReplicatedStorage.Shared.Util).itemUtils
                            local sharedValues = require(ReplicatedStorage.Shared.Values)
                            local data = DataController:getData()
                            
                            if not data then return end
                            
                            -- Get max equippable pets
                            local maxEquippable = sharedValues.dungeonMaxEquip(LocalPlayer, data)
                            
                            -- Get all dungeon pets and sort by multiplier
                            local dungeonPets = {}
                            
                            if data.inventory.pet then
                                for petId, _ in pairs(data.inventory.pet) do
                                    local pet = itemUtils.getItemFromId(data, petId)
                                    if pet and pet:getSpecialMultiplierName() == "dungeonDamage" then
                                        table.insert(dungeonPets, {
                                            id = petId,
                                            multiplier = pet:getSpecialMultiplierAmount(),
                                            amount = pet:getAmount()
                                        })
                                    end
                                end
                            end
                            
                            -- Sort by multiplier (highest first)
                            table.sort(dungeonPets, function(a, b)
                                return a.multiplier > b.multiplier
                            end)
                            
                            -- Get best pets to equip
                            local bestPetsToEquip = {}
                            local totalPetsToEquip = 0
                            
                            for _, petData in ipairs(dungeonPets) do
                                if totalPetsToEquip < maxEquippable then
                                    local petsToEquip = math.min(petData.amount, maxEquippable - totalPetsToEquip)
                                    if petsToEquip > 0 then
                                        bestPetsToEquip[petData.id] = petsToEquip
                                        totalPetsToEquip = totalPetsToEquip + petsToEquip
                                    end
                                end
                            end
                            
                            -- Remove pets that shouldn't be equipped
                            if data.dungeonTeam then
                                for equippedPetId, equippedAmount in pairs(data.dungeonTeam) do
                                    local shouldKeep = bestPetsToEquip[equippedPetId]
                                    local correctAmount = shouldKeep and bestPetsToEquip[equippedPetId] or 0
                                    
                                    if not shouldKeep or equippedAmount > correctAmount then
                                        -- Remove excess or unwanted pets
                                        local removeAmount = equippedAmount - correctAmount
                                        for i = 1, removeAmount do
                                            DungeonService:removePetFromTeam(equippedPetId)
                                            task.wait(0.1)
                                        end
                                    end
                                end
                            end
                            
                            -- Add best pets that aren't equipped or need more
                            for petId, targetAmount in pairs(bestPetsToEquip) do
                                local currentEquipped = (data.dungeonTeam and data.dungeonTeam[petId]) or 0
                                local needToAdd = targetAmount - currentEquipped
                                
                                for i = 1, needToAdd do
                                    DungeonService:addPetToTeam(petId)
                                    task.wait(0.1)
                                end
                            end
                        end)
                        
                        task.wait(5) -- Check every 5 seconds
                    end
                end)
            end
        end
    })

    local DungeonAutoJoinSection = Tabs.Dunegon:AddSection("Auto Join Dungeon")

    -- Status element to show dungeon tickets
    local ticketStatus = DungeonAutoJoinSection:AddParagraph("Dungeon",{
        Title = "Dungeon Tickets",
        Content = "Checking..."
    })

    -- Function to update ticket status
    local function updateTicketStatus()
        pcall(function()
            local data = DataController:getData()
            local dungeonTicketItem = require(ReplicatedStorage.Shared.Util).itemUtils.getItemFromName(data, "dungeonTicket")
            
            if dungeonTicketItem and dungeonTicketItem:getAmount() > 0 then
                ticketStatus:SetValue("Dungeon Tickets: " .. dungeonTicketItem:getAmount())
            else
                ticketStatus:SetValue("No Dungeon Tickets")
            end
        end)
    end

    -- Update tickets every 5 seconds
    task.spawn(function()
        while true do
            updateTicketStatus()
            task.wait(5)
        end
    end)

    -- Get dungeon gamemodes for dropdown
    local DungeonGamemodes = require(ReplicatedStorage.Shared.List.Dungeon.DungeonGamemodes)
    local gamemodeOptions = {}
    for i, gamemode in ipairs(DungeonGamemodes) do
        table.insert(gamemodeOptions, string.format("%d. %s (%d tickets)", i, gamemode.name, gamemode.price))
    end

    -- Dropdown for gamemode selection
    local selectedGamemode = 1
    local gamemodeDropdown = DungeonAutoJoinSection:Dropdown("GamemodeSelect", {
        Title = "Select Dungeon Mode",
        Values = gamemodeOptions,
        Multi = false,
        Default = 1,
        Callback = function(Value)
            -- Extract the number from the selected option
            local gamemodeNumber = string.match(Value, "^(%d+)")
            selectedGamemode = tonumber(gamemodeNumber) or 1
        end
    })

    -- Auto join toggle
    local autoJoinEnabled = false
    DungeonAutoJoinSection:Toggle("AutoJoinDungeon", {
        Title = "Auto Join Dungeon",
        Description = "Automatically joins the selected dungeon gamemode. The game has no bosses in level 101, so if the script's aren't doing anything, it's because you will need to wait out the timer.",
        Default = false,
        Callback = function(Value)
            autoJoinEnabled = Value
            if Value then
                task.spawn(function()
                    -- Instant check when toggle is enabled
                    if not isInDungeon() then
                        pcall(function()
                            DungeonService:startDungeon(selectedGamemode)
                        end)
                        task.wait(3) 
                    else
                        task.wait(3)
                    end
                    
                    while autoJoinEnabled do
                        if not isInDungeon() then
                            pcall(function()
                                DungeonService:startDungeon(selectedGamemode)
                            end)
                            task.wait(3) 
                        else
                            task.wait(3) 
                        end
                    end
                end)
            end
        end
    })

    local DungeonUISection = Tabs.Dunegon:AddSection("Misc")

    local isHUDOverrideEnabled = false
    local isStopScreenShakeEnabled = false
    local originalHideHUD = nil
    local originalShakeScreen = nil
    local originalCriticalTap = nil

    DungeonUISection:Toggle("KeepHUDVisible", {
        Title = "Keep HUD Visible",
        Description = "Prevents the dungeon from hiding your HUD. This must be on before entering a dungeon to work.",
        Default = false,
        Callback = function(enabled)
            isHUDOverrideEnabled = enabled
            local Knit = require(game:GetService("ReplicatedStorage").Packages.Knit)
            local UIController = Knit.GetController("UIController")
            if enabled then
                if not originalHideHUD then
                    originalHideHUD = UIController.hideHUD
                end
                UIController.hideHUD = function(self, hide, exceptions)
                    originalHideHUD(self, false, {["bottom"] = true})
                end
            else
                if originalHideHUD then
                    UIController.hideHUD = originalHideHUD
                end
            end
        end
    })

    DungeonUISection:Toggle("StopScreenShakes", {
        Title = "Stop Screen Shakes",
        Description = "Prevents dungeon screen shakes and critical tap effects.",
        Default = false,
        Callback = function(enabled)
            isStopScreenShakeEnabled = enabled
            local Knit = require(game:GetService("ReplicatedStorage").Packages.Knit)
            local DC = Knit.GetController("DungeonController")
            if enabled then
                if not originalShakeScreen then
                    originalShakeScreen = DC.shakeScreen
                end
                if not originalCriticalTap then
                    originalCriticalTap = DC.criticalTap
                end
                DC.shakeScreen = function() end
                DC.criticalTap = function() end
            else
                if originalShakeScreen then
                    DC.shakeScreen = originalShakeScreen
                end
                if originalCriticalTap then
                    DC.criticalTap = originalCriticalTap
                end
            end
        end
    })
    
    local isPreventTeleportEnabled = false
    local originalTeleportFromRoom = nil

    DungeonUISection:Toggle("PreventTeleport", {
        Title = "Prevent Teleport",
        Description = "Prevents teleporting when the dungeon ends. DO NOT use this unless you are using the Auto Join Dungeon toggle, or you will be stuck.",
        Default = false,
        Callback = function(enabled)
            isPreventTeleportEnabled = enabled
            local Knit = require(game:GetService("ReplicatedStorage").Packages.Knit)
            task.wait(2)
            local DC = Knit.GetController("DungeonController")
            if enabled then
                if not originalTeleportFromRoom then
                    originalTeleportFromRoom = DC.teleportFromRoom
                end
                DC.teleportFromRoom = function()
                end
            else
                if originalTeleportFromRoom then
                    DC.teleportFromRoom = originalTeleportFromRoom
                end
            end
        end
    })

    DungeonMerchant = Tabs.Dunegon:AddSection("Dungeon Shop")

    -- Get all dungeon shop items
    local function getAllDungeonShopItems()
        local options = {}
        local itemMap = {}
        
        pcall(function()
            local DungeonShop = require(ReplicatedStorage.Shared.List.Dungeon.Shop)
            
            for i, shopItem in ipairs(DungeonShop) do
                local item = shopItem.item
                local price = shopItem.price
                
                -- Get item name and amount using proper methods
                local itemName = "Unknown Item"
                local itemAmount = 1
                
                pcall(function()
                    -- Use the proper methods to get name and amount
                    if item.getName then
                        itemName = item:getName()
                    elseif item.getRealName then
                        itemName = item:getRealName()
                    end
                    
                    -- Get the amount using the proper method
                    if item.getAmount then
                        itemAmount = item:getAmount()
                    end
                end)
                
                -- Format display name with amount if greater than 1
                local displayName
                if itemAmount > 1 then
                    displayName = string.format("%dx %s - %s coins", itemAmount, itemName, Functions.suffixes(price))
                else
                    displayName = string.format("%s - %s coins", itemName, Functions.suffixes(price))
                end
                
                table.insert(options, displayName)
                itemMap[displayName] = {
                    item = item,
                    price = price,
                    index = i,
                    amount = itemAmount,
                    itemName = itemName  -- Store the actual name for comparison
                }
            end
        end)
        
        return options, itemMap
    end

    local dungeonShopOptions, dungeonShopItemMap = getAllDungeonShopItems()
    local selectedShopItems = {}

    -- Dropdown for selecting items
    local shopItemDropdown = DungeonMerchant:Dropdown("SelectShopItems", {
        Title = "Select Items to Auto Buy",
        Values = dungeonShopOptions,
        Multi = true,
        Searchable = true,
        Default = {},
        Callback = function(value)
            selectedShopItems = value
        end
    })


    DungeonMerchant:Button({
    Title = "Select All",
    Description = "Selects all dungeon shop items.",
    Callback = function()
        local allSelected = {}
        for _, optionName in ipairs(dungeonShopOptions) do
            allSelected[optionName] = true
        end
        shopItemDropdown:SetValue(allSelected)
        selectedShopItems = allSelected
    end})

    -- Auto buy toggle
    local autoBuyShopEnabled = false
    DungeonMerchant:Toggle("AutoBuyShopItems", {
        Title = "Auto Buy Selected Items",
        Description = "Automatically buys selected items when they appear in the dungeon shop",
        Default = false,
        Callback = function(Value)
            autoBuyShopEnabled = Value
            if Value then
                task.spawn(function()
                    while autoBuyShopEnabled do
                        if next(selectedShopItems) then
                            pcall(function()
                                local DungeonShop = require(ReplicatedStorage.Shared.List.Dungeon.Shop)
                                local playerData = DataController:getData()
                                if not playerData then return end
                                
                                -- Get current dungeon coins
                                local dungeonCoins = playerData.dungeonCoins or 0
                                
                                -- Get current shop hour for seed generation
                                local timeData = DateTime.fromUnixTimestamp(Knit.serverTimeNow + 3600):ToUniversalTime()
                                
                                -- Check each shop slot (1-3)
                                for slot = 1, 3 do
                                    local seed = timeData.Year * 222 + timeData.Month * 333 + timeData.Day * 444444 + timeData.Hour * 33333 + LocalPlayer.UserId + slot
                                    local shopItem = DungeonShop[Functions.getRandom(DungeonShop, seed)]
                                    
                                    if shopItem then
                                        local item = shopItem.item
                                        local price = shopItem.price
                                        
                                        -- Check if already bought
                                        local boughtKey = string.format("%d", seed)
                                        local isBought = playerData.dungeonShopBought[boughtKey] or false
                                        
                                        if not isBought and dungeonCoins >= price then
                                            -- Get item name using proper methods
                                            local itemName = "Unknown Item"
                                            local itemAmount = 1
                                            
                                            pcall(function()
                                                if item.getName then
                                                    itemName = item:getName()
                                                elseif item.getRealName then
                                                    itemName = item:getRealName()
                                                end
                                                
                                                if item.getAmount then
                                                    itemAmount = item:getAmount()
                                                end
                                            end)
                                            
                                            -- Check if this item is selected for auto buy
                                            for displayName, isSelected in pairs(selectedShopItems) do
                                                if isSelected and dungeonShopItemMap[displayName] then
                                                    local selectedItem = dungeonShopItemMap[displayName]
                                                    
                                                    -- Compare item names, amounts, and prices
                                                    if itemName == selectedItem.itemName and 
                                                    itemAmount == selectedItem.amount and 
                                                    price == selectedItem.price then
                                                        DungeonService:buyShop(slot)
                                                        task.wait(1)
                                                        break
                                                    end
                                                end
                                            end
                                        end
                                    end
                                end
                            end)
                        end
                        task.wait(5) -- Check every 5 seconds
                    end
                end)
            end
        end
    })


    DungeonUpgrades = Tabs.Dunegon:AddSection("Auto Buy Upgrades")

    -- Get all dungeon upgrades for dropdown
    local function getAllDungeonUpgrades()
        local options = {}
        local upgradeMap = {}
        
        pcall(function()
            local DungeonUpgrades = require(ReplicatedStorage.Shared.List.Dungeon.Upgrades)
            
            for upgradeId, upgradeData in pairs(DungeonUpgrades) do
                local displayName = Functions.toPascal(upgradeId)
                table.insert(options, displayName)
                upgradeMap[displayName] = upgradeId
            end
        end)
        
        table.sort(options)
        return options, upgradeMap
    end

    local dungeonUpgradeOptions, dungeonUpgradeMap = getAllDungeonUpgrades()
    local selectedDungeonUpgrades = {}

    -- Dropdown for selecting upgrades
    local dungeonUpgradeDropdown = DungeonUpgrades:Dropdown("SelectDungeonUpgrades", {
        Title = "Select Upgrades to Auto Buy",
        Values = dungeonUpgradeOptions,
        Multi = true,
        Searchable = true,
        Default = {},
        Callback = function(value)
            selectedDungeonUpgrades = value
        end
    })

    -- Auto upgrade toggle
    local autoDungeonUpgradeEnabled = false
    DungeonUpgrades:Toggle("AutoUpgrade", {
        Title = "Auto Upgrade",
        Description = "Automatically buys selected dungeon upgrades when you can afford them",
        Default = false,
        Callback = function(Value)
            autoDungeonUpgradeEnabled = Value
            if Value then
                task.spawn(function()
                    while autoDungeonUpgradeEnabled do
                        if next(selectedDungeonUpgrades) then
                            local upgradesBought = 0
                            
                            pcall(function()
                                local playerData = DataController:getData()
                                if not playerData then return end
                                
                                local DungeonUpgradesModule = require(ReplicatedStorage.Shared.List.Dungeon.Upgrades)
                                local dungeonCoins = playerData.dungeonCoins or 0
                                
                                -- Check each selected upgrade
                                for displayName, isSelected in pairs(selectedDungeonUpgrades) do
                                    if isSelected and dungeonUpgradeMap[displayName] then
                                        local upgradeId = dungeonUpgradeMap[displayName]
                                        local upgradeData = DungeonUpgradesModule[upgradeId]
                                        
                                        if upgradeData then
                                            local currentLevel = playerData.dungeonUpgrades[upgradeId] or 0
                                            local nextLevel = currentLevel + 1
                                            
                                            -- Check if there's a next level available
                                            if upgradeData.upgrades[nextLevel] then
                                                local upgradeCost = upgradeData.upgrades[nextLevel].cost or 0
                                                
                                                -- Check if player can afford it
                                                if dungeonCoins >= upgradeCost then
                                                    -- Convert to lowercase for service call
                                                    local lowercaseUpgradeId = upgradeId:sub(1,1):lower() .. upgradeId:sub(2)
                                                    DungeonService:upgrade(lowercaseUpgradeId)
                                                    
                                                    upgradesBought = upgradesBought + 1
                                                    dungeonCoins = dungeonCoins - upgradeCost -- Update local coins count
                                                    
                                                    task.wait(0.25) -- 0.25 second delay between purchases
                                                    
                                                    -- Update player data for next iteration
                                                    playerData = DataController:getData()
                                                    if playerData then
                                                        dungeonCoins = playerData.dungeonCoins or 0
                                                    end
                                                end
                                            end
                                        end
                                    end
                                end
                            end)
                        end
                        
                        task.wait(3) -- Check every 3 seconds
                    end
                end)
            end
        end
    })


    local AutoCraftSection = Tabs.Craft:AddSection("Auto Craft")

    AutoCraftSection:Paragraph("AutoCraftSectionParagraph", {
        Title = "Note",
        Content = "You will not visually get a message that you have crafted something, but it will have been built. This will also use items that might be rare, so be careful with what you select. If something still appears as unbuilt, rejoin.",
        TitleAlignment = "Middle",
        ContentAlignment = Enum.TextXAlignment.Left
    })

    ResourceStatusParagraph = AutoCraftSection:Paragraph("ResourceStatus", {
        Title = "Resource Status",
        Content = "Select buildings to see resource requirements",
        TitleAlignment = "Middle",
        ContentAlignment = Enum.TextXAlignment.Left
    })

    -- Shared variables for the entire section
    local autoCraftDropdown, autoCraftBuildingMap, ResourceStatusParagraph
    local isAutoCraftEnabled = false
    local originalAutoCraftSettings = {}

    local function getUnbuiltBuildings()
        local options, buildingMap = {}, {}
        pcall(function()
            local Buildings = require(ReplicatedStorage.Shared.List.Buildings)
            local playerData = DataController:getData()
            if not playerData then return end

            for buildingId, buildingData in pairs(Buildings) do
                local isBuilt = playerData.buildings and playerData.buildings[buildingId] or false
                if not isBuilt and buildingData.name and buildingData.required then
                    local displayName = buildingData.name
                    table.insert(options, displayName)
                    buildingMap[displayName] = buildingId
                end
            end
        end)
        table.sort(options)
        return options, buildingMap
    end

    local function canAffordBuilding(buildingId)
        local Buildings = require(ReplicatedStorage.Shared.List.Buildings)
        local buildingData = Buildings[buildingId]
        if not buildingData or not buildingData.required then return false end
        
        local playerData = DataController:getData()
        if not playerData then return false end
        
        for _, requiredItem in ipairs(buildingData.required) do
            local itemName = requiredItem:getName()
            local requiredAmount = requiredItem:getAmount()
            
            local currentItem = Util.itemUtils.getItemFromName(playerData, itemName)
            local currentAmount = currentItem and currentItem:getAmount() or 0
            
            if currentAmount < requiredAmount then
                return false
            end
        end
        return true
    end

    local function getPrerequisiteChain(buildingId, visited)
        visited = visited or {}
        if visited[buildingId] then return {} end
        visited[buildingId] = true
        
        local Buildings = require(ReplicatedStorage.Shared.List.Buildings)
        local buildingData = Buildings[buildingId]
        if not buildingData then return {} end
        
        local chain = {}
        if buildingData.previousBuilding then
            local prereqChain = getPrerequisiteChain(buildingData.previousBuilding, visited)
            for _, prereq in ipairs(prereqChain) do
                table.insert(chain, prereq)
            end
            table.insert(chain, buildingData.previousBuilding)
        end
        
        return chain
    end

    local function getMissingResources()
        local Buildings = require(ReplicatedStorage.Shared.List.Buildings)
        local playerData = DataController:getData()
        if not playerData then return {} end
        
        local missingResources = {}
        
        if autoCraftDropdown and autoCraftDropdown.Value then
            for buildingName, isSelected in pairs(autoCraftDropdown.Value) do
                if isSelected then
                    local buildingId = autoCraftBuildingMap[buildingName]
                    local buildingData = Buildings[buildingId]
                    
                    if buildingData and buildingData.required then
                        for _, requiredItem in ipairs(buildingData.required) do
                            local itemName = requiredItem:getName()
                            local requiredAmount = requiredItem:getAmount()
                            
                            local currentItem = Util.itemUtils.getItemFromName(playerData, itemName)
                            local currentAmount = currentItem and currentItem:getAmount() or 0
                            
                            if currentAmount < requiredAmount then
                                local needed = requiredAmount - currentAmount
                                if missingResources[itemName] then
                                    missingResources[itemName] = missingResources[itemName] + needed
                                else
                                    missingResources[itemName] = needed
                                end
                            end
                        end
                    end
                end
            end
        end
        
        return missingResources
    end

    local function updateResourceStatus()
        local missingResources = getMissingResources()
        
        if next(missingResources) == nil then
            if ResourceStatusParagraph then
                ResourceStatusParagraph:SetValue("✅ All selected buildings can be crafted!")
            end
            return
        end
        
        local statusLines = {"📋 Missing Resources:"}
        for itemName, amount in pairs(missingResources) do
            table.insert(statusLines, string.format("  • %s: %s", itemName, Functions.comma(amount)))
        end
        
        if ResourceStatusParagraph then
            ResourceStatusParagraph:SetValue(table.concat(statusLines, "\n"))
        end
    end

    local function mapWoodToTreeWorldForCraft(woodName)
        if woodName:lower() == "wood" then return "spawn" end
        
        local Trees = require(ReplicatedStorage.Shared.List.Trees)
        for zoneName, zoneData in pairs(Trees) do
            if zoneData.trees and #zoneData.trees > 0 then
                local treeInfo = zoneData.trees[1]
                if treeInfo and treeInfo.item then
                    local item = treeInfo.item
                    local itemName = item.id or item.Name or item.name or 
                        (typeof(item.getId) == "function" and item:getId()) or 
                        (typeof(item.getName) == "function" and item:getName())
                    if itemName and itemName:lower() == woodName:lower() then 
                        return zoneName 
                    end
                end
            end
        end
        return "spawn"
    end

    -- Initialize building options
    local autoCraftOptions, initialBuildingMap = getUnbuiltBuildings()
    autoCraftBuildingMap = initialBuildingMap

    AutoCraftSection:Button({
    Title = "Enable Recommended Settings",
    Description = "Automatically enables: Auto Equip Best Axe, Reduce Cutting Cooldown, and Axe Strength Bypass",
    Callback = function()
        -- Enable the 3 recommended toggles using their actual variable names
        AutoEquip:SetValue(true)
        lowercooldown:SetValue(true) 
        BypassStrength:SetValue(true)
    end})

    -- Create the dropdown
    autoCraftDropdown = AutoCraftSection:Dropdown("SelectBuildingsToCraft", {
        Title = "Select Buildings to Auto Craft",
        Description = "Crafts all selected buildings that you can afford and automatically farms trees for needed wood.",
        Values = autoCraftOptions,
        Multi = true,
        Searchable = true,
        Default = {}
    })

    ResourceStatusParagraph = AutoCraftSection:Paragraph("ResourceStatus", {
        Title = "Resource Status",
        Content = "Select buildings to see resource requirements",
        TitleAlignment = "Middle",
        ContentAlignment = Enum.TextXAlignment.Left
    })

    autoCraftDropdown:OnChanged(function(value)
        updateResourceStatus()
    end)

    AutoCraftSection:Toggle("AutoCraft", {
        Title = "Auto Craft Selected Buildings",
        Description = "Automatically crafts selected buildings and farms trees for wood resources. Turn on auto auto equip best axe, reduce cutting cooldown, and axe strength bypass for the best results.",
        Default = false,
        Callback = function(enabled)
            isAutoCraftEnabled = enabled
            
            if enabled then
                -- Store original tree cutting settings
                originalAutoCraftSettings.selectedTrees = {}
                for treeObject, isSelected in pairs(SelectTreesDropdown.Value) do
                    originalAutoCraftSettings.selectedTrees[treeObject] = isSelected
                end
                originalAutoCraftSettings.autoCutState = autoBreakRunning
                
                -- Start auto craft loop
                task.spawn(function()
                    while isAutoCraftEnabled do
                        pcall(function()
                            local playerData = DataController:getData()
                            if not playerData then return end
                            
                            local Buildings = require(ReplicatedStorage.Shared.List.Buildings)
                            local selectedBuildings = autoCraftDropdown.Value or {}
                            
                            -- Check what we need to farm
                            local neededWoods = {}
                            local canCraftSomething = false
                            
                            for buildingName, isSelected in pairs(selectedBuildings) do
                                if isSelected then
                                    local buildingId = autoCraftBuildingMap[buildingName]
                                    local buildingData = Buildings[buildingId]
                                    
                                    if buildingData then
                                        -- Check prerequisites first
                                        local prereqChain = getPrerequisiteChain(buildingId)
                                        
                                        -- Try to build prerequisites
                                        for _, prereqId in ipairs(prereqChain) do
                                            local isPrereqBuilt = playerData.buildings and playerData.buildings[prereqId] or false
                                            if not isPrereqBuilt and canAffordBuilding(prereqId) then
                                                BuildingService:build(prereqId)
                                                task.wait(1)
                                                canCraftSomething = true
                                            end
                                        end
                                        
                                        -- Try to build main building
                                        local isBuilt = playerData.buildings and playerData.buildings[buildingId] or false
                                        if not isBuilt then
                                            if canAffordBuilding(buildingId) then
                                                BuildingService:build(buildingId)
                                                task.wait(2)
                                                canCraftSomething = true
                                            else
                                                -- Check what resources we need
                                                if buildingData.required then
                                                    for _, requiredItem in ipairs(buildingData.required) do
                                                        local itemName = requiredItem:getName()
                                                        local requiredAmount = requiredItem:getAmount()
                                                        
                                                        local currentItem = Util.itemUtils.getItemFromName(playerData, itemName)
                                                        local currentAmount = currentItem and currentItem:getAmount() or 0
                                                        
                                                        if currentAmount < requiredAmount and itemName:lower():find("wood") then
                                                            table.insert(neededWoods, itemName)
                                                        end
                                                    end
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                            
                            -- Update tree selection for farming
                            if #neededWoods > 0 then
                                local neededTreeObjects = {}
                                for _, woodName in ipairs(neededWoods) do
                                    local treeWorld = mapWoodToTreeWorldForCraft(woodName)
                                    for _, treeObject in ipairs(SelectTreesDropdown.Values) do
                                        if treeObject.Value == treeWorld then
                                            neededTreeObjects[treeObject] = true
                                            break
                                        end
                                    end
                                end
                                
                                SelectTreesDropdown:SetValue(neededTreeObjects)
                                
                                -- Enable tree cutting if not already enabled
                                if not autoBreakRunning then
                                    AutoCutTreesToggle:SetValue(true)
                                end
                            elseif canCraftSomething then
                                -- Stop tree cutting if we don't need wood and crafted something
                                if autoBreakRunning then
                                    AutoCutTreesToggle:SetValue(false)
                                end
                            end
                        end)
                        
                        task.wait(3) -- Check every 3 seconds
                    end
                end)
                
            else 
                -- Restore original settings
                if next(originalAutoCraftSettings) then
                    SelectTreesDropdown:SetValue(originalAutoCraftSettings.selectedTrees)
                    
                    if autoBreakRunning ~= originalAutoCraftSettings.autoCutState then
                        AutoCutTreesToggle:SetValue(originalAutoCraftSettings.autoCutState)
                    end
                end
            end
        end
    })


    AutoCraftSection:Button({
        Title = "Refresh Building List",
        Description = "Updates the list of available buildings to craft",
        Callback = function()
            local newOptions, newBuildingMap = getUnbuiltBuildings()
            autoCraftOptions = newOptions
            autoCraftBuildingMap = newBuildingMap
            autoCraftDropdown:SetValues(newOptions)
            autoCraftDropdown:SetValue({})
            updateResourceStatus()
        end
    })

    task.spawn(function()
        while true do
            local newOptions, newBuildingMap = getUnbuiltBuildings()
            autoCraftOptions = newOptions
            autoCraftBuildingMap = newBuildingMap
            autoCraftDropdown:SetValues(newOptions)
            updateResourceStatus()
            task.wait(5)
        end
    end)

    explorerroom = Tabs.Craft:AddSection("Scattered Items")

    explorerroom:Paragraph("WorldMap", {
        Title = "World Map",
        Content = "To get the world map, you will need to follow these steps. Teleport to Desert (don't move), then teleport to Tech City (don't move), then teleport to Volcano (don't move). Next, teleport to spawn, and manually go through every world without teleporting, up to spaceship. Finally teleport to Heaven, and you will unlock it.",
        TitleAlignment = "Middle",
        ContentAlignment = Enum.TextXAlignment.Left
    })

    explorerroom:Button({
        Title = "Claim Hints",
        Description = "Automatically claims all available explorer hints",
        Callback = function()
            pcall(function()
                local Knit = require(ReplicatedStorage.Packages.Knit)
                local ExplorerService = Knit.GetService("ExplorerService")
                local DataController = Knit.GetController("DataController")
                local UIController = Knit.GetController("UIController")
                
                DataController:waitForData()
                local playerData = DataController:getData()

                local hintsCollected = 0
                
                -- Try to collect hint 1
                if not playerData.explorerHints.hint1 then
                    local result = ExplorerService:collectHint(1)
                    if result == "success" then
                        hintsCollected = hintsCollected + 1
                        task.wait(1)
                    end
                end
                
                -- Try to collect hint 2 (requires hint 1 to be collected first)
                playerData = DataController:getData() -- Refresh data
                if playerData.explorerHints.hint1 and not playerData.explorerHints.hint2 then
                    local result = ExplorerService:collectHint(2)
                    if result == "success" then
                        hintsCollected = hintsCollected + 1
                    end
                end
                
                if hintsCollected > 0 then
                else
                end
            end)
        end
    })

    explorerroom:Button({
        Title = "Get all Scattered Explorer Items",
        Description = "Like the title says, you will get the scattered items - e.g globe",
        Callback = function()
            pcall(function()
                local explorerRoom = workspace.Game.Maps.Spaceship:FindFirstChild("extra explorer room")
                if not explorerRoom then
                    warn("Extra explorer room not found!")
                    return
                end
                
                local activatedCount = 0
                local totalItems = 0
                
                for _, item in pairs(explorerRoom:GetChildren()) do
                    totalItems = totalItems + 1
                    local proximityPrompt = item:FindFirstChildOfClass("ProximityPrompt")
                    
                    if proximityPrompt then
                        pcall(function()
                            fireproximityprompt(proximityPrompt)
                            activatedCount = activatedCount + 1
                        end)
                        task.wait(1) 
                    end
                end
            end)
        end
    })


    ActivateLeversSection = Tabs.Craft:AddSection("Activate Levers")

    ActivateLeversSection:Toggle("AutoActivateLevers", {
        Title = "Activate Light Switches",
        Description = "Automatically activates built light switches that haven't been activated yet",
        Default = false,
        Callback = function(Value)
            local autoActivateEnabled = Value
            if Value then
                task.spawn(function()
                    while autoActivateEnabled do
                        pcall(function()
                            local Buildings = require(ReplicatedStorage.Shared.List.Buildings)
                            local playerData = DataController:getData()
                            if not playerData then return end
                            
                            for buildingId, buildingData in pairs(Buildings) do
                                if buildingId:lower():find("lightswitch") then
                                    local isBuilt = playerData.buildings and playerData.buildings[buildingId] or false
                                    
                                    if isBuilt then
                                        local switchNumber = buildingId:match("lightSwitch(%d+)")
                                        if switchNumber then
                                            local switchId = tonumber(switchNumber)
                                            
                                            local isActivated = table.find(playerData.lightSwitches or {}, switchId) ~= nil
                                            
                                            if not isActivated then
                                                local Knit = require(ReplicatedStorage.Packages.Knit)
                                                Knit.GetService("RewardService").activateLightSwitch._re:FireServer(switchId)
                                                task.wait(1)
                                            end
                                        end
                                    end
                                end
                            end
                        end)
                        
                        task.wait(3)
                    end
                end)
            else
                autoActivateEnabled = false
            end
        end
    })


    ClaimSection = Tabs.Claim:AddSection("Claim/Collect")

    local isAutoCollectEnabled = false
    local autoCollectThread = nil

    local function claimChestsInUnlockedMaps()
        if not game:IsLoaded() then game.Loaded:Wait() end
        task.wait(1)

        local Knit = require(ReplicatedStorage.Packages.Knit)
        local Maps = require(ReplicatedStorage.Shared.List.Maps)

        local DataController
        repeat
            DataController = Knit.GetController("DataController")
            task.wait()
        until DataController

        local function getUnlockedZones()
            local playerData = DataController:getData()
            if not playerData or not playerData.maps then return {} end
            local unlockedMapIds = playerData.maps
            local unlockedZones = {}
            for mapId, mapData in pairs(Maps) do
                if mapData.alwaysUnlocked or table.find(unlockedMapIds, mapId) then
                    mapData.id = mapId
                    table.insert(unlockedZones, mapData)
                end
            end
            table.sort(unlockedZones, function(a, b) return a.id < b.id end)
            return unlockedZones
        end

        local function formatZoneName(name)
            return (name:gsub("%s+", ""))
        end

        local function firePrompt(prompt)
            if prompt and prompt:IsA("ProximityPrompt") and prompt.Enabled then
                fireproximityprompt(prompt, math.huge)
            end
        end

        local function getZonePrompts(chestFolder)
            local prompts = {}
            for _, chest in ipairs(chestFolder:GetChildren()) do
                local touch = chest:FindFirstChild("Touch")
                if touch then
                    local prompt = touch:FindFirstChildOfClass("ProximityPrompt")
                    if prompt and prompt.Enabled then
                        table.insert(prompts, prompt)
                    end
                end
            end
            return prompts
        end

        local function beginChestCollection()
            local character = game.Players.LocalPlayer.Character or game.Players.LocalPlayer.CharacterAdded:Wait()
            local humanoidRootPart = character:WaitForChild("HumanoidRootPart")
            local originalCFrame = humanoidRootPart.CFrame

            local unlockedZones = getUnlockedZones()
            if #unlockedZones == 0 then return end

            for _, zoneData in ipairs(unlockedZones) do
                if not isAutoCollectEnabled then break end 
                if not zoneData.cframe then continue end

                local zoneName = formatZoneName(zoneData.name)
                local mapFolder = Workspace:FindFirstChild("Game") and Workspace.Game.Maps:FindFirstChild(zoneName)
                if not mapFolder then continue end
                local chestFolder = mapFolder:FindFirstChild("MiniChests")
                if not chestFolder then continue end

                humanoidRootPart:PivotTo(zoneData.cframe)
                task.wait(2)

                local lastCount = 0
                local sameCountDuration = 0
                local noPromptCount = 0

                while isAutoCollectEnabled do
                    local prompts = getZonePrompts(chestFolder)
                    local currentCount = #prompts

                    if currentCount == lastCount then
                        sameCountDuration += 1
                    else
                        sameCountDuration = 0
                    end
                    lastCount = currentCount

                    if sameCountDuration >= 10 then
                        break
                    end

                    if #prompts == 0 then
                        noPromptCount += 1
                        if noPromptCount >= 3 then
                            break
                        end
                    else
                        noPromptCount = 0
                        for _, prompt in ipairs(prompts) do
                            if not isAutoCollectEnabled then break end
                            firePrompt(prompt)
                            task.wait(0.25)
                        end
                    end
                    task.wait(1)
                end

                task.wait(1)
            end

            humanoidRootPart:PivotTo(originalCFrame)
        end

        pcall(beginChestCollection)
    end

    -- 💠 Toggle for Auto Chest Collection
    ClaimSection:Toggle("Auto Collect Mini-Chests", {
        Title = "Auto Collect Mini-Chests",
        Description = "Automatically teleports through unlocked zones and collects all mini-chests until stopped.",
        Default = false,
        Callback = function(enabled)
            isAutoCollectEnabled = enabled

            if enabled then
                autoCollectThread = task.spawn(function()
                    while isAutoCollectEnabled do
                        claimChestsInUnlockedMaps()
                        task.wait(5)
                    end
                end)
            else
                if autoCollectThread then
                    task.cancel(autoCollectThread)
                    autoCollectThread = nil
                end
            end
        end
    })


    ClaimSection:Toggle("AutoPickUp", { Title = "Auto Pick Up", Default = false,
        Callback = function(enabled)
            _G.AutoPickUpEnabled = enabled
            if _G.AutoPickUpThread then task.cancel(_G.AutoPickUpThread); _G.AutoPickUpThread = nil end
            if enabled then
                _G.AutoPickUpThread = task.spawn(function()
                    local orbsFolder = Workspace:FindFirstChild("Debris") and Workspace.Debris:FindFirstChild("Orbs")
                    if not orbsFolder then return end
                    while _G.AutoPickUpEnabled and task.wait(0.2) do
                        local character, hrp = LocalPlayer.Character, nil
                        if character and character:FindFirstChild("HumanoidRootPart") then hrp = character.HumanoidRootPart else continue end
                        local orbsToCollect = {}
                        for _, orb in ipairs(orbsFolder:GetChildren()) do
                            if orb:IsA("BasePart") then
                                orb:SetAttribute("canCollect", true); orb.Anchored = true
                                if (orb.Position - hrp.Position).Magnitude <= math.huge then
                                    table.insert(orbsToCollect, orb.Name)
                                    local attachment = hrp:FindFirstChild("_orbAttachment" .. orb.Name); if attachment then attachment:Destroy() end
                                end
                            end
                        end
                        if #orbsToCollect > 0 then
                            pcall(function() OrbService.collectOrbs:Fire(orbsToCollect) end)
                            for _, orbName in ipairs(orbsToCollect) do local orb = orbsFolder:FindFirstChild(orbName); if orb then orb:Destroy() end end
                        end
                    end
                end)
            end
        end
    })

    pickupStarsThread = nil
    ClaimSection:Toggle("PickupStars", { Title = "Pickup Stars",
        Callback = function(enabled)
            if pickupStarsThread then task.cancel(pickupStarsThread); pickupStarsThread = nil end
            if enabled then
                pickupStarsThread = task.spawn(function()
                    while enabled do
                        local hrp = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
                        local debris = Workspace:FindFirstChild("Debris")
                        if hrp and debris then
                            for _, starModel in ipairs(debris:GetChildren()) do
                                if starModel.Name == "FallingStar" then
                                    local starCore = starModel.PrimaryPart
                                    local hideFolder = starCore and starCore:FindFirstChild("hideAfterLanding")
                                    if hideFolder then
                                        local isStillFalling = false
                                        for _, particle in ipairs(hideFolder:GetChildren()) do
                                            if particle:IsA("ParticleEmitter") and particle.Enabled == true then
                                                isStillFalling = true
                                                break
                                            end
                                        end
                                        if not isStillFalling then
                                            pcall(firetouchinterest, hrp, starCore, 0)
                                            pcall(firetouchinterest, hrp, starCore, 1)
                                            break
                                        end
                                    end
                                end
                            end
                        end
                        task.wait(0.1)
                    end
                end)
            end
        end
    })


    local autoClaimThreads = {}
    createClaimToggle = function(id, title, claimFunc)
        ClaimSection:Toggle("AutoClaim"..id, { Title = title, Default = false,
            Callback = function(enabled)
                if autoClaimThreads[id] then task.cancel(autoClaimThreads[id]); autoClaimThreads[id]=nil end
                if enabled then autoClaimThreads[id] = task.spawn(function() while enabled do pcall(claimFunc); task.wait(5) end end) end
            end
        })
    end

    createClaimToggle("Achievements", "Auto Claim Achievements", function()
        local Achievements = require(ReplicatedStorage.Shared.List.Achievements)
        DataController:waitForData()
        local playerData = DataController:getData()
        for achievementKey, achievementData in pairs(Achievements) do
            local currentLevel = 1
            for claimedId, _ in pairs(playerData.claimedAchievements) do if claimedId:find(achievementKey) then currentLevel = currentLevel + 1 end end
            if #achievementData.list >= currentLevel and achievementData.list[currentLevel].amount <= achievementData.getValue(playerData) then
                RewardService:claimAchievement(achievementKey); task.wait(1)
            end
        end
    end)
    createClaimToggle("Playtime", "Auto Claim Playtime Rewards", function()
        local PlaytimeRewards = require(ReplicatedStorage.Shared.List.PlaytimeRewards)
        DataController:waitForData()
        local playerData = DataController:getData()
        for rewardId, rewardData in pairs(PlaytimeRewards) do
            local adjustedRequired = rewardData.required * (1 - Values.playtimeRewardCooldown(LocalPlayer, playerData))
            if adjustedRequired - playerData.playtimeRewardTimer <= 0 and not table.find(playerData.claimedPlaytimeRewards, rewardId) then
                RewardService:claimPlaytimeReward(rewardId); task.wait(1)
            end
        end
    end)
    createClaimToggle("Daily", "Auto Claim Daily Reward", function()
        DataController:waitForData()
        local playerData = DataController:getData()
        if workspace:GetServerTimeNow() - playerData.dayReset >= 86400 and math.max(0, 600 - (playerData.dailyRewardRequiredTime or 0)) <= 0 then
            RewardService:claimDailyReward(); task.wait(1)
        end
    end)

    createClaimToggle("Prestige", "Auto Prestige", function()
        local PrestigeService = Knit.GetService("PrestigeService")
        local Prestiges = require(ReplicatedStorage.Shared.List.Prestige.Prestiges)
        DataController:waitForData()
        local playerData = DataController:getData()
        
        if playerData then
            local currentPrestige = playerData.prestige
            local currentPrestigeXP = playerData.prestigeXp
            local nextPrestige = Prestiges[currentPrestige + 1]
            
            if nextPrestige and currentPrestigeXP >= nextPrestige.required then
                PrestigeService:claim()
                task.wait(1)
            end
        end
    end)

    local IndexService = Knit.GetService("IndexService")
    local DataController = Knit.GetController("DataController")
    local PetController = Knit.GetController("PetController")

    local IndexRewards = require(ReplicatedStorage.Shared.List.IndexRewards)
    local Util = require(ReplicatedStorage.Shared.Util)

    ClaimSection:Toggle("AutoClaimIndexRewards", {
        Title = "Auto Claim Index Rewards",
        Default = false,
        Callback = function(enabled)
            autoClaimIndexRewardsEnabled = enabled
            if enabled then
                task.spawn(function()
                    DataController:waitForData()
                    while autoClaimIndexRewardsEnabled do
                        local playerData = DataController:getData()
                        if playerData then
                            local claimed = playerData.claimedIndexRewards or {}
                            local existTable = PetController:getExistTable()
                            local indexedCount = Util.indexUtils.countIndex(playerData, existTable)

                            for rewardId, rewardData in pairs(IndexRewards) do
                                local required = rewardData.required or 0
                                local alreadyClaimed = table.find(claimed, rewardId)


                                if indexedCount >= required and not alreadyClaimed then
                                    -- Claim reward every second until successful
                                    task.spawn(function()
                                        while autoClaimIndexRewardsEnabled and not table.find((DataController:getData().claimedIndexRewards or {}), rewardId) do
                                            local success, err = pcall(function()
                                                IndexService:claimIndexReward(rewardId)
                                            end)
                                            if success then
                                            else
                                            end
                                            task.wait(1)
                                        end
                                    end)
                                end
                            end
                        else
                        end
                        task.wait(5)
                    end
                end)
            else
            end
        end
    })
    
    autoClaimAllChestsThread, originalIsInGroup = nil, nil
    ClaimSection:Toggle("AutoClaimAllChests", { Title = "Auto Claim All Chests", Default = false,
        Callback = function(enabled)
            if enabled then
                if not originalIsInGroup then originalIsInGroup = Functions.isInGroup end
                Functions.isInGroup = function() return true end
                if autoClaimAllChestsThread then task.cancel(autoClaimAllChestsThread) end
                autoClaimAllChestsThread = task.spawn(function()
                    DataController:waitForData()
                    local Chests = require(ReplicatedStorage.Shared.List.Chests)
                    while enabled do
                        local playerData = DataController:getData()
                        local serverTime = Knit.serverTimeNow or os.time()
                        for chestId, chestData in pairs(Chests) do
                            local lastClaim = playerData.chests[chestId] or 0
                            local cooldown = chestData.cooldown - Values.chestCooldown(LocalPlayer, playerData)
                            if cooldown - (serverTime - lastClaim) <= 0 then
                                RewardService:claimChest(chestId, true); task.wait(0.2)
                            end
                        end
                        task.wait(10)
                    end
                end)
            else
                if autoClaimAllChestsThread then task.cancel(autoClaimAllChestsThread); autoClaimAllChestsThread=nil end
                if originalIsInGroup then Functions.isInGroup = originalIsInGroup; originalIsInGroup=nil end
            end
        end
    })

    supplyDropThread = nil
    ClaimSection:Toggle("OpenSupplyDrops", { Title = "Open Supply Drops", Default = false,
        Callback = function(enabled)
            if supplyDropThread then task.cancel(supplyDropThread); supplyDropThread = nil end
            if enabled then
                supplyDropThread = task.spawn(function()
                    while enabled do
                        local debris = Workspace:FindFirstChild("Debris")
                        if debris then
                            for _, dropEvent in ipairs(debris:GetChildren()) do
                                if dropEvent.Name:find("SupplyDropEvent") then
                                    for _, obj in ipairs(dropEvent:GetChildren()) do
                                        local prompt = obj:FindFirstChild("ProximityPrompt"); if prompt then pcall(fireproximityprompt, prompt) end
                                    end
                                end
                            end
                        end
                        task.wait(1)
                    end
                end)
            end
        end
    })

    AncientWheel = Tabs.Misc:AddSection("Ancient Wheel")
    isAutoSpinEnabled = false
    AncientWheel:Toggle("AutoSpin", { Title = "Auto Spin Ancient Wheel", Default = false,
        Callback = function(enabled)
            isAutoSpinEnabled = enabled
            task.spawn(function()
                while isAutoSpinEnabled do
                    pcall(function() RewardService:ancientWheelSpin() end)
                    task.wait(0.01)
                end
            end)
        end
    })

    
    ClanWheel = Tabs.Misc:AddSection("Clan Wheel")
    isAutoSpinEnabled1 = false
    ClanWheel:Toggle("AutoSpin1", { Title = "Auto Spin Clan Wheel", Default = false,
        Callback = function(enabled)
            isAutoSpinEnabled1 = enabled
            task.spawn(function()
                while isAutoSpinEnabled1 do
                    pcall(function() ClanService:clanWheelSpin()() end)
                    task.wait(60)
                end
            end)
        end
    })

    BoostWheel = Tabs.Misc:AddSection("Boost Wheel")
    isAutoSpinEnabled12 = false
    BoostWheel:Toggle("AutoSpin12", { Title = "Auto Spin Boost Wheel", Default = false,
        Callback = function(enabled)
            isAutoSpinEnabled12 = enabled
            task.spawn(function()
                while isAutoSpinEnabled12 do
                    pcall(function() RewardService:boostWheelSpin()() end)
                    task.wait(60)
                end
            end)
        end
    })


    AncientMerchantSection = Tabs.Misc:AddSection("Ancient Merchant")

    getAllAncientMerchantItems = function()
        local options, itemMap = {}, {}
        pcall(function()
            local AncientMerchant = require(ReplicatedStorage.Shared.List.AncientMerchant)
            for i, offer in ipairs(AncientMerchant) do
                local name, amount, price = offer.item.nm or "Unknown Item", offer.item.am or 1, offer.price or 0
                local displayName = string.format("%s - %d Ancient Tickets", (amount > 1 and (amount .. "x " .. name)) or name, price)
                table.insert(options, displayName)
                itemMap[displayName] = {name = name, amount = amount, price = price}
            end
        end)
        return options, itemMap
    end

    local merchantOptions, merchantItemMap = getAllAncientMerchantItems()
    local selectedMerchantItems = {}

    AncientMerchantSection:Dropdown("SelectItems", {Title = "Select Items", Values = merchantOptions, Multi = true, Searchable = true, Default = {}, Callback = function(value) selectedMerchantItems = value end})

    isAutoBuyEnabled = false
    AncientMerchantSection:Toggle("AutoBuy", {Title = "Auto Buy", Description = "Automatically buys selected items when they appear in the merchant", Default = false, Callback = function(enabled)
        isAutoBuyEnabled = enabled
        if enabled then
            task.spawn(function()
                while isAutoBuyEnabled do
                    if next(selectedMerchantItems) then
                        pcall(function()
                            local AncientMerchantList = require(ReplicatedStorage.Shared.List.AncientMerchant)
                            DataController:waitForData()
                            local data, boughtData, serverTimeNow = DataController:getData(), (DataController:getData()).ancientMerchantBought or {}, Knit.serverTimeNow or os.time()
                            for slot = 1, Values.ancientMerchantSlots(LocalPlayer, data) do
                                local ts = DateTime.fromUnixTimestamp(serverTimeNow + 3600):ToUniversalTime()
                                local seed = ts.Year * 222 + ts.Month * 333 + ts.Day * 444444 + ts.Hour * 33333 + LocalPlayer.UserId + slot
                                local itemData = AncientMerchantList[Functions.getRandom(AncientMerchantList, seed)]
                                if itemData then
                                    local merchantItem = itemData.item
                                    local merchantName = merchantItem.nm or "Unknown"
                                    local merchantAmount = merchantItem.am or 1
                                    
                                    for displayName, isSelected in pairs(selectedMerchantItems) do
                                        if isSelected and merchantItemMap[displayName] then
                                            local selectedItem = merchantItemMap[displayName]
                                            if merchantName == selectedItem.name and merchantAmount == selectedItem.amount then
                                                local key = string.format("%*", seed)
                                                if not boughtData[key] then
                                                    local ancientTickets = 0
                                                    if data.inventory and data.inventory.exclusive then 
                                                        for itemId, item in pairs(data.inventory.exclusive) do 
                                                            if item.nm == "ancientTicket" then 
                                                                ancientTickets = item.am or 0
                                                                break 
                                                            end 
                                                        end 
                                                    end
                                                    if ancientTickets >= selectedItem.price then 
                                                        RewardService:buyAncientMerchant(slot)
                                                        task.wait(2) 
                                                    end
                                                end
                                                break
                                            end
                                        end
                                    end
                                end
                            end
                        end)
                    end
                    task.wait(5)
                end
            end)
        end
    end})


    PassSection = Tabs.Misc:AddSection("Season Pass")
    PassSection:Toggle("AutoClaimToggle", { Title = "Auto Claim Season Rewards", Description = "Automatically claims all available season pass rewards.", Default = false, Callback = function(s) _G.AutoClaimToggle = s end })
    PassSection:Toggle("AutoResetPassToggle", { Title = "Auto Reset Season Pass", Description = "Automatically resets the pass AFTER all rewards have been claimed.", Default = false, Callback = function(s) _G.AutoResetPassToggle = s end })

    task.spawn(function()
        while task.wait(5) do
            if not (_G.AutoClaimToggle or _G.AutoResetPassToggle) then continue end
            pcall(function()
                local playerData = DataController:getData(); if not playerData then return end
                local seasonNum, currentPassLevel, hasPremiumPass, claimedTiersData, totalTiers = seasonVariables.season, seasonUtils.seasonUtils.getLevel(playerData), playerData[("season%*PassPremium"):format(seasonVariables.season)], playerData[("season%*PassClaimed"):format(seasonVariables.season)], #seasonTiersList
                local allRewardsClaimed = true

                for tier = 1, totalTiers do
                    if tier > currentPassLevel then allRewardsClaimed = false; break end
                    for track = 1, 2 do
                        if track == 2 and not hasPremiumPass then continue end
                        local rewardKey = ("%*%*"):format(track, tier)
                        
                        if not claimedTiersData[rewardKey] then
                            allRewardsClaimed = false
                            if _G.AutoClaimToggle then
                                SeasonService:claimTier(tier, track)
                                task.wait(0.2)
                            end
                        end
                    end
                end
                
                if _G.AutoResetPassToggle and allRewardsClaimed then SeasonService:resetPass() end
            end)
        end
    end)


    Aura = Tabs.Misc:AddSection("Aura")
    local AuraDices = require(ReplicatedStorage.Shared.List.Items.AuraDices)
    selectedDiceItems, autoRollThread = {}, nil
    local diceNames, diceOptions = {}, {}
    do local names = {} for name, info in pairs(AuraDices) do table.insert(names, info.name); diceOptions[info.name]=name end table.sort(names); diceNames=names end

    updateDiceStatus = function()
        local statusLines, hasSelected = {}, false
        pcall(function()
            DataController:waitForData()
            local playerData = DataController:getData()
            for diceName, isSelected in pairs(selectedDiceItems) do
                if isSelected then
                    hasSelected = true
                    local item = Util.itemUtils.getItemFromName(playerData, diceOptions[diceName])
                    table.insert(statusLines, string.format("%s (%dx)", diceName, (item and item:getAmount() or 0)))
                end
            end
        end)
        return not hasSelected and "No dice selected" or table.concat(statusLines, "\n")
    end

    local AuraDiceDropdown = Aura:Dropdown("SelectAuraDice", { Title = "Select Aura Dice", Values = diceNames, Multi = true, Searchable = true, Default = {} })
    local SelectedDiceParagraph = Aura:Paragraph("SelectedDiceDisplay", { Title = "Selected Dice", Content = "No dice selected" })
    AuraDiceDropdown:OnChanged(function(value) selectedDiceItems = value end)

    Aura:Toggle("AutoRoll", { Title = "Auto Roll", Default = false,
        Callback = function(enabled)
            if autoRollThread then task.cancel(autoRollThread); autoRollThread = nil end
            if enabled then
                autoRollThread = task.spawn(function()
                    while enabled do
                        local availableDice = {}
                        pcall(function()
                            DataController:waitForData(); local playerData = DataController:getData()
                            for diceName, isSelected in pairs(selectedDiceItems) do
                                if isSelected then local item=Util.itemUtils.getItemFromName(playerData, diceOptions[diceName]); if item and item:getAmount()>0 then table.insert(availableDice, diceOptions[diceName]) end end
                            end
                        end)
                        if #availableDice > 0 then pcall(function() AuraService:roll(availableDice[math.random(1,#availableDice)]) end) end
                        task.wait(1)
                    end
                end)
            end
        end
    })

    task.spawn(function() while true do SelectedDiceParagraph:SetValue(updateDiceStatus()); task.wait(1) end end)

    local CraftDiceSection = Tabs.Misc:AddSection("Craft Dice")

    -- Get all aura dice crafting recipes
    local AuraDiceCrafting = require(ReplicatedStorage.Shared.List.AuraDiceCrafting)
    local diceCraftOptions, diceCraftMap = {}, {}

    for i, recipe in ipairs(AuraDiceCrafting) do
        local requiredName = recipe.item:getName()
        local rewardName = recipe.reward:getName()
        local displayName = requiredName .. " → " .. rewardName
        table.insert(diceCraftOptions, displayName)
        diceCraftMap[displayName] = {
            recipeIndex = i,
            requiredName = requiredName,
            rewardName = rewardName,
            requiredAmount = recipe.item:getAmount(),
            rewardId = rewardName
        }
    end

    local selectedDiceCrafts = {}

    local DiceCraftDropdown = CraftDiceSection:Dropdown("SelectDiceCrafts", {
        Title = "Select Dice to Craft",
        Description = "Choose which aura dice to craft",
        Values = diceCraftOptions,
        Multi = true,
        Searchable = true,
        Default = {},
        Callback = function(value)
            selectedDiceCrafts = value
        end
    })

    local isAutoCraftDiceEnabled = false

    CraftDiceSection:Toggle("CraftAllDice", {
        Title = "Craft All (Selected)",
        Description = "Automatically crafts all selected aura dice as much as possible",
        Default = false,
        Callback = function(enabled)
            isAutoCraftDiceEnabled = enabled
            if enabled then
                task.spawn(function()
                    while isAutoCraftDiceEnabled do
                        pcall(function()
                            DataController:waitForData()
                            local playerData = DataController:getData()
                            for displayName, isSelected in pairs(selectedDiceCrafts) do
                                if isSelected and diceCraftMap[displayName] then
                                    local craftInfo = diceCraftMap[displayName]
                                    local requiredItem = AuraDiceCrafting[craftInfo.recipeIndex].item
                                    local rewardItem = AuraDiceCrafting[craftInfo.recipeIndex].reward
                                    local requiredName = craftInfo.requiredName
                                    local requiredAmount = craftInfo.requiredAmount
                                    local rewardId = craftInfo.recipeIndex

                                    local playerItem = Util.itemUtils.getItemFromName(playerData, requiredName)
                                    local playerAmount = playerItem and playerItem:getAmount() or 0
                                    local maxCraftable = math.floor(playerAmount / requiredAmount)

                                    if maxCraftable > 0 then
                                        local Knit = require(ReplicatedStorage.Packages.Knit)
                                        local AuraService = Knit.GetService("AuraService")
                                        AuraService:craftDice(rewardId, maxCraftable)
                                        task.wait(1)
                                    end
                                end
                            end
                        end)
                        task.wait(5)
                    end
                end)
            end
        end
    })
    

    EventSection = Tabs.Misc:AddSection("Events")
    isAutoBreakingMeteors = false
    EventSection:Toggle("AutoBreakMeteors", { Title = "Auto Break Meteors (Infinite Range)", Default = false,
        Callback = function(Value)
            isAutoBreakingMeteors = Value
            if Value then
                task.spawn(function()
                    while isAutoBreakingMeteors do
                        local allMeteors = CollectionService:GetTagged("Meteor")
                        if #allMeteors > 0 then
                            while #allMeteors > 0 and isAutoBreakingMeteors do
                                for _, meteor in ipairs(allMeteors) do
                                    pcall(function() local id=meteor:GetAttribute("meteorId"); if id then EventService.damageMeteor:Fire(id) end end)
                                end
                                task.wait()
                                allMeteors = CollectionService:GetTagged("Meteor")
                            end
                        end
                        task.wait(5)
                    end
                end)
            end
        end
    })

    -- Hand the library over to our managers
    SaveManager:SetLibrary(Library)
    InterfaceManager:SetLibrary(Library)
    SaveManager:IgnoreThemeSettings()
    SaveManager:SetIgnoreIndexes{}
    InterfaceManager:SetFolder("FluentScriptHub")
    SaveManager:SetFolder("FluentScriptHub/specific-game")
    InterfaceManager:BuildInterfaceSection(Tabs.Settings)
    SaveManager:BuildConfigSection(Tabs.Settings)
    Window:SelectTab(1)
    SaveManager:LoadAutoloadConfig()
end

task.spawn(function()
    if not game:IsLoaded() then game.Loaded:Wait() end

    Knit = require(ReplicatedStorage.Packages.Knit)
    Knit.OnStart():await()

    ClickService = Knit.GetService("ClickService")
    EggService = Knit.GetService("EggService")
    RebirthService = Knit.GetService("RebirthService")
    TreeService = Knit.GetService("TreeService")
    AxeService = Knit.GetService("AxeService")
    InventoryService = Knit.GetService("InventoryService")
    PetService = Knit.GetService("PetService")
    RewardService = Knit.GetService("RewardService")
    ClanService = Knit.GetService("ClanService")
    UpgradeService = Knit.GetService("UpgradeService")
    SeasonService = Knit.GetService("SeasonService")
    FarmService = Knit.GetService("FarmService")
    AuraService = Knit.GetService("AuraService")
    EventService = Knit.GetService("EventService")
    OrbService = Knit.GetService("OrbService")
    BuildingService = Knit.GetService("BuildingService")
    LumberjackService = Knit.GetService("LumberjackService")
    DungeonService = Knit.GetService("DungeonService")
    
    DataController = Knit.GetController("DataController")
    EggController = Knit.GetController("EggController")
    TreeController = Knit.GetController("TreeController")
    AuraController = Knit.GetController("AuraController")
    MapController = Knit.GetController("MapController")
    OrbController = Knit.GetController("OrbController")
    ItemController = Knit.GetController("ItemController")
    SoundController = Knit.GetController("SoundController")
    FarmController = Knit.GetController("FarmController")
    BuildingController = Knit.GetController("BuildingController")
    HatchingController = require(LocalPlayer:WaitForChild("PlayerScripts"):WaitForChild("Client"):WaitForChild("Controllers"):WaitForChild("HatchingController"))
    
    Functions = require(ReplicatedStorage.Shared.Functions)
    seasonVariables = require(ReplicatedStorage.Shared.Variables)
    seasonUtils = require(ReplicatedStorage.Shared.Util)
    seasonTiersList = require(ReplicatedStorage.Shared.List[("Season%*"):format(seasonVariables.season)].Tiers)
    Util = require(ReplicatedStorage.Shared.Util)
    Values = require(ReplicatedStorage.Shared.Values)   

    Window = Library:Window{
        Title = "RCU",
        SubTitle = "By Duckie",
        TabWidth = 160,
        Size =  UDim2.fromOffset(580, 460),
        Resize = false,
        Theme = "Darker",
        MinimizeKey = Enum.KeyCode.LeftShift
    }

    Tabs = {
        Settings = Window:AddTab({ Title = "Settings", Icon = "settings" }),
        Main = Window:AddTab({ Title = "Auto Farm", Icon = "crown" }),
        Eggs = Window:AddTab({ Title = "Eggs", Icon = "egg" }),
        Tree = Window:AddTab({ Title = "Axe/Tree", Icon = "phosphor-tree-evergreen-duotone" }),
        Farm = Window:AddTab({ Title = "Farming", Icon = "phosphor-farm-bold" }),
        Pet = Window:AddTab({ Title = "Pet Crafting", Icon = "paw-print" }),
        Quest = Window:AddTab({ Title = "Quests", Icon = "phosphor-scroll-bold" }),
        Machine = Window:AddTab({ Title = "Machines/Minigames", Icon = "phosphor-game-controller-bold" }),
        Dunegon = Window:AddTab({ Title = "Dungeon", Icon = "phosphor-shield-checkered-bold" }),
        Craft = Window:AddTab({ Title = "Building", Icon = "hammer" }),
        Claim = Window:AddTab({ Title = "Auto Claim/Collect", Icon = "gift" }),
        Misc = Window:AddTab({ Title = "Misc", Icon = "sparkles" }),
    }

    BuildUI()
end)

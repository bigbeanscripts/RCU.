local Library = loadstring(game:HttpGetAsync("https://github.com/ActualMasterOogway/Fluent-Renewed/releases/latest/download/Fluent.luau"))()
local SaveManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/bigbeanscripts/Pet-Warriors/refs/heads/main/test"))()
local InterfaceManager = loadstring(game:HttpGetAsync("https://raw.githubusercontent.com/ActualMasterOogway/Fluent-Renewed/master/Addons/InterfaceManager.luau"))()
loadstring(game:HttpGet("https://raw.githubusercontent.com/SenhorLDS/ProjectLDSHUB/refs/heads/main/Anti%20AFK"))()

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local LocalPlayer = Players.LocalPlayer

-- Global variables for game services and controllers
local Knit, ClickService, UpgradeService, DataController, Functions, Util, Values

-- Global variables for UI window and tabs
local Window, Tabs

spawn(function()
    while wait(30) do 
        pcall(function() collectgarbage("collect") end)
    end
end)

BuildUI = function()

    local mobDropdown, AutoHitToggle, EquipBest, HitSpeed, AutoUpgradeSwordToggle, AutoRebirthToggle

    local AutoClickSection = Tabs.Halloween:AddSection("Auto Click")

    AutoClickSection:Toggle("AutoClick", {
        Title = "Auto Click",
        Description = "Automatically clicks for you - Extremely fast!",
        Default = false,
        Callback = function(Value)
            AutoClicking = Value
            if Value then
                task.spawn(function()
                    while AutoClicking do
                        ClickService.click._re:FireServer()
                        task.wait(0.001)
                    end
                end)
            end
        end
    })

   local HalloweenHatchSection = Tabs.Halloween:AddSection("Auto Hatch (Halloween)")

    -- Get egg names from the Halloween map and add the special boss egg
    local halloweenEggOptions = {}
    pcall(function()
        local eggFolder = Workspace.Game.Maps:FindFirstChild("0Halloween") and Workspace.Game.Maps["0Halloween"]:FindFirstChild("Eggs")
        if eggFolder then
            for _, eggModel in ipairs(eggFolder:GetChildren()) do table.insert(halloweenEggOptions, eggModel.Name) end
        end
    end)
    table.insert(halloweenEggOptions, "Halloween (Boss)")
    
    local selectedHalloweenEgg = halloweenEggOptions[1] or "Basic"

    -- UI Element 1: Egg Selection Dropdown
    HalloweenHatchSection:Dropdown("SelectHalloweenEgg", {
        Title = "Select Egg",
        Values = halloweenEggOptions,
        Default = selectedHalloweenEgg,
        Callback = function(value) selectedHalloweenEgg = value end
    })

    -- UI Element 2: Hatch Amount Dropdown
    local halloweenHatchAmounts = {["1x"]=1, ["3x"]=3, ["Max"]=99}
    local selectedHalloweenAmount = halloweenHatchAmounts["Max"]
    HalloweenHatchSection:Dropdown("SelectHalloweenHatchAmount", {
        Title = "Select Hatch Amount",
        Values = {"1x", "3x", "Max"},
        Default = "Max",
        Callback = function(value) selectedHalloweenAmount = halloweenHatchAmounts[value] or 1 end
    })

    -- UI Element 3: Lucky Eggs Toggle
    local useHalloweenLuckyEggs = false
    HalloweenHatchSection:Toggle("UseHalloweenLuckyEggs", {
        Title = "Use Lucky Eggs",
        Description = "Does not apply to the 'Halloween (Boss)' egg.",
        Default = false,
        Callback = function(enabled) useHalloweenLuckyEggs = enabled end
    })

    -- Ensure the global hatch delay logic is present
    if not _G.SmartHatchDelay then
        _G.SmartHatchDelay = 4.11
        task.spawn(function()
            local hatchTimeLabel = LocalPlayer.PlayerGui.MainUI.Menus.SettingsFrame.Main.List.Multipliers.HatchingSpeed.Main.Amount
            while true do
                pcall(function()
                    local numberString = string.match(hatchTimeLabel.Text, "%d+%.?%d*")
                    if numberString then _G.SmartHatchDelay = (tonumber(numberString) or 4.01) + 0.1 end
                end)
                task.wait(5)
            end
        end)
    end
    
    -- UI Element 4: Auto Hatch Toggle
    local autoHalloweenHatchThread = nil
    HalloweenHatchSection:Toggle("AutoHatchHalloween", {
        Title = "Auto Hatch Event Eggs",
        Default = false,
        Callback = function(enabled)
            if autoHalloweenHatchThread then task.cancel(autoHalloweenHatchThread); autoHalloweenHatchThread = nil end
            if enabled then
                autoHalloweenHatchThread = task.spawn(function()
                    while enabled do
                        pcall(function()
                            if selectedHalloweenEgg == "Halloween (Boss)" then
                                Knit.GetService("EggService").openEgg._re:FireServer("Halloween", selectedHalloweenAmount, {isBossCave = true})
                            else
                                local args = {selectedHalloweenEgg, selectedHalloweenAmount}
                                if useHalloweenLuckyEggs then
                                    local anyAvailableLuckyId = next((Knit.GetController("EggController"))._luckyEggs or {})
                                    if anyAvailableLuckyId then table.insert(args, {luckyEggId = anyAvailableLuckyId}) end
                                end
                                Knit.GetService("EggService").openEgg._re:FireServer(unpack(args))
                            end
                        end)
                        task.wait(_G.SmartHatchDelay)
                    end
                end)
            end
        end
    })

    -- UI Element 5: Hide Animation Toggle
    HalloweenHatchSection:Toggle("HideHalloweenHatchAnimation", {
        Title = "Hide Hatch Animation",
        Default = false,
        Callback = function(Value)
            local HatchingController = require(LocalPlayer:WaitForChild("PlayerScripts"):WaitForChild("Client"):WaitForChild("Controllers"):WaitForChild("HatchingController"))
            local function overrideFunctions(shouldHide)
                if not HatchingController._originalFunctions and shouldHide then
                    HatchingController._originalFunctions = {
                        playEggAnimation = HatchingController.playEggAnimation, playHatchingAnimation = HatchingController.playHatchingAnimation,
                        animatePetIn = HatchingController.animatePetIn, animatePetOut = HatchingController.animatePetOut,
                        dropEggs = HatchingController.dropEggs, shakeEggs = HatchingController.shakeEggs,
                        scaleAndRemoveEggs = HatchingController.scaleAndRemoveEggs, playRevealSounds = HatchingController.playRevealSounds
                    }
                end
                local emptyFunc = function() return nil end
                for funcName, originalFunc in pairs(HatchingController._originalFunctions or {}) do
                    HatchingController[funcName] = shouldHide and emptyFunc or originalFunc
                end
            end
            overrideFunctions(Value)
        end
    })
    
    local MiniChestsSection = Tabs.Halloween:AddSection("Mini Chests")
    
    local collectChestsThread = nil

    MiniChestsSection:Toggle("CollectMiniChests", {
        Title = "Collect Mini Chests",
        Description = "Automatically collects the mini chests in the Halloween world. You must be in the Halloween map for this to work.",
        Default = false,
        Callback = function(enabled)
            if collectChestsThread then
                task.cancel(collectChestsThread)
                collectChestsThread = nil
            end

            if enabled then
                collectChestsThread = task.spawn(function()
                    while enabled do
                        pcall(function()
                            local chestsFolder = Workspace.Game.Maps:FindFirstChild("0Halloween") 
                                and Workspace.Game.Maps["0Halloween"]:FindFirstChild("MiniChests")

                            if chestsFolder then
                                for _, chest in ipairs(chestsFolder:GetChildren()) do
                                    local touchPart = chest:FindFirstChild("Touch")
                                    local prompt = touchPart and touchPart:FindFirstChildOfClass("ProximityPrompt")

                                    if prompt and prompt.Enabled then
                                        fireproximityprompt(prompt)
                                        task.wait(2)
                                    end
                                end
                            end
                        end)
                        task.wait(5)
                    end
                end)
            end
        end
    })

    local HalloweenShopSection = Tabs.Halloween:AddSection("Halloween Shop")

    local shopItemNames = {}
    local shopItemMap = {}
    local autoBuyShopThread = nil

    pcall(function()
        local HalloweenShopList = require(ReplicatedStorage.Shared.List.Halloween.HalloweenShop)
        local itemsToSort = {}

        for id, cost in pairs(HalloweenShopList) do
            local displayName = string.format("%s (Cost: %s)", id, Functions.suffixes(cost))
            table.insert(itemsToSort, { display = displayName, id = id, cost = cost })
            shopItemMap[displayName] = { id = id, cost = cost }
        end

        table.sort(itemsToSort, function(a, b) return a.cost < b.cost end)

        for _, itemData in ipairs(itemsToSort) do
            table.insert(shopItemNames, itemData.display)
        end
    end)

    local shopDropdown = HalloweenShopSection:Dropdown("SelectShopItems", {
        Title = "Select Items to Auto Buy",
        Values = shopItemNames,
        Multi = true,
        Searchable = true,
        Default = {}
    })

    HalloweenShopSection:Toggle("AutoBuyShopItems", {
        Title = "Auto Buy",
        Description = "Automatically buys selected items you don't own and can afford.",
        Default = false,
        Callback = function(enabled)
            if autoBuyShopThread then
                task.cancel(autoBuyShopThread)
                autoBuyShopThread = nil
            end

            if enabled then
                autoBuyShopThread = task.spawn(function()
                    while enabled do
                        pcall(function()
                            local selectedItems = shopDropdown.Value
                            if not next(selectedItems) then return end

                            local playerData = DataController:getData()
                            local candyCornItem = Util.itemUtils.getItemFromName(playerData, "candyCorns")
                            local myCandyCorns = candyCornItem and candyCornItem:getAmount() or 0
                            local playerOwnedData = playerData.halloweenShop or {}

                            for displayName, isSelected in pairs(selectedItems) do
                                if isSelected then
                                    local shopData = shopItemMap[displayName]
                                    if not playerOwnedData[shopData.id] and myCandyCorns >= shopData.cost then
                                        -- Corrected function name from buyHalloweenShop to buyShop
                                        Knit.GetService("HalloweenService"):buyShop(shopData.id)
                                        myCandyCorns = myCandyCorns - shopData.cost
                                        task.wait(1)
                                    end
                                end
                            end
                        end)
                        task.wait(5)
                    end
                end)
            end
        end
    })
    

    local HalloweenRewardsSection = Tabs.Halloween:AddSection("Halloween Rewards")

    local autoClaimRewardThread = nil

    HalloweenRewardsSection:Toggle("AutoClaimHalloweenReward", {
        Title = "Auto Claim Halloween Rewards",
        Description = "Automatically claims rewards when you have Halloween Tickets.",
        Default = false,
        Callback = function(enabled)
            if autoClaimRewardThread then
                task.cancel(autoClaimRewardThread)
                autoClaimRewardThread = nil
            end

            if enabled then
                autoClaimRewardThread = task.spawn(function()
                    while enabled do
                        pcall(function()
                            local playerData = DataController:getData()
                            if not playerData then return end
                            local halloweenTicketItem = Util.itemUtils.getItemFromName(playerData, "halloweenTicket")
                            local ticketAmount = halloweenTicketItem and halloweenTicketItem:getAmount() or 0
                            if ticketAmount > 0 then
                                Knit.GetService("HalloweenService"):claimHalloweenReward()
                            end
                        end)
                        task.wait(0.25)
                    end
                end)
            end
        end
    })

    local CursedChestSection = Tabs.Halloween:AddSection("Cursed Chest")
    
    local useOneKeyThread, useAllKeysThread = nil, nil

    CursedChestSection:Toggle("AutoUseOneCursedKey", {
        Title = "Use 1x Cursed Key",
        Description = "Uses one Cursed Key (every second).",
        Default = false,
        Callback = function(enabled)
            if useOneKeyThread then task.cancel(useOneKeyThread); useOneKeyThread = nil end
            if enabled then
                useOneKeyThread = task.spawn(function()
                    while enabled do
                        pcall(function() Knit.GetService("HalloweenService"):cursedChest() end)
                        task.wait(1)
                    end
                end)
            end
        end
    })

    CursedChestSection:Toggle("AutoUseAllCursedKeys", {
        Title = "Use All Cursed Keys",
        Description = "Uses all available Cursed Keys every 5 seconds.",
        Default = false,
        Callback = function(enabled)
            if useAllKeysThread then task.cancel(useAllKeysThread); useAllKeysThread = nil end
            if enabled then
                useAllKeysThread = task.spawn(function()
                    while enabled do
                        pcall(function() Knit.GetService("HalloweenService"):cursedChest(true) end)
                        task.wait(5)
                    end
                end)
            end
        end
    })

    local HalloweenMobsSection = Tabs.Halloween:AddSection("Halloween Mobs")

    local mobNames = {}
    local MobsModule = nil
    local autoHitThread = nil

    pcall(function()
        MobsModule = require(ReplicatedStorage.Shared.List.Halloween.Mobs)
        for id, data in pairs(MobsModule) do table.insert(mobNames, id) end
        table.sort(mobNames)
    end)
    
    mobDropdown = HalloweenMobsSection:Dropdown("SelectMobs", {
        Title = "Select Mobs to Target",
        Values = mobNames,
        Multi = true,
        Searchable = true,
        Default = {}
    })

    local AutoHitToggle = HalloweenMobsSection:Toggle("AutoHit", {
        Title = "Auto Kill Mobs",
        Description = "Kills selected mobs. If none of the selected mbos are available, it will kill mobs based on your weapon damage.",
        Default = false,
        Callback = function(enabled)
            if autoHitThread then task.cancel(autoHitThread); autoHitThread = nil end

            if enabled then
                autoHitThread = task.spawn(function()
                    while enabled do
                        pcall(function()
                            local selectedMobTypes = mobDropdown.Value
                            local playerData = DataController:getData()
                            local activeMobs = playerData and playerData.mobs
                            
                            if not activeMobs or not next(activeMobs) then return end

                            local availableTypes = {}
                            for instanceId, mobData in pairs(activeMobs) do
                                if selectedMobTypes[mobData.mobId] then
                                    local mobId = mobData.mobId; availableTypes[mobId] = availableTypes[mobId] or {}
                                    if MobsModule[mobId] then table.insert(availableTypes[mobId], { id = instanceId, health = MobsModule[mobId].hp - (mobData.damage or 0) }) end
                                end
                            end

                            local target
                            local typeKeys = {}; for typeName in pairs(availableTypes) do table.insert(typeKeys, typeName) end

                            if #typeKeys > 0 then
                                local chosenTypeName = typeKeys[math.random(1, #typeKeys)]
                                local mobsOfChosenType = availableTypes[chosenTypeName]
                                local lowestHealth = math.huge
                                for _, mob in ipairs(mobsOfChosenType) do if mob.health < lowestHealth then lowestHealth = mob.health end end
                                local weakestTies = {}; for _, mob in ipairs(mobsOfChosenType) do if mob.health == lowestHealth then table.insert(weakestTies, mob) end end
                                if #weakestTies > 0 then target = weakestTies[math.random(1, #weakestTies)] end
                            else
                                local HalloweenItems = require(ReplicatedStorage.Shared.List.Items.HalloweenEvent)
                                local bestSwordInfo, bestIndex = nil, -1
                                for _, itemData in pairs(playerData.inventory.halloweenEvent or {}) do
                                    local itemStats = HalloweenItems[itemData.nm]
                                    if itemStats and itemStats.index and itemStats.index > bestIndex then bestIndex, bestSwordInfo = itemStats.index, itemStats end
                                end
                                
                                if bestSwordInfo then
                                    local damageLimit = bestSwordInfo.multiplier * 25
                                    local viableTargets = {}
                                    for instanceId, mobData in pairs(activeMobs) do
                                        local mobStats = MobsModule[mobData.mobId]
                                        if mobStats and mobStats.hp <= damageLimit then
                                            table.insert(viableTargets, { id = instanceId, name = mobData.mobId, health = mobStats.hp - (mobData.damage or 0) })
                                        end
                                    end

                                    if #viableTargets > 0 then
                                        table.sort(viableTargets, function(a, b) return a.health > b.health end)
                                        target = viableTargets[1]
                                    end
                                end

                                if not target then
                                    local lowestHealth = math.huge
                                    for instanceId, mobData in pairs(activeMobs) do
                                        local mobStats = MobsModule[mobData.mobId]
                                        if mobStats then
                                            local currentHealth = mobStats.hp - (mobData.damage or 0)
                                            if currentHealth < lowestHealth then
                                                lowestHealth, target = currentHealth, {id = instanceId, name = mobData.mobId, health = currentHealth}
                                            end
                                        end
                                    end
                                end
                            end

                            if target and target.id then
                                Knit.GetService("HalloweenService").damage._re:FireServer(target.id)
                            end
                        end)
                        task.wait(0.25)
                    end
                end)
            end
        end
    })

    local originalWeaponSpeed = Values.weaponSpeed
    local HitSpeed = HalloweenMobsSection:Toggle("IncreaseSwordSpeed", {
        Title = "Increase Sword Speed",
        Description = "Makes your sword swing much faster. This works best when hitting mobs manually.",
        Default = false,
        Callback = function(Value)
            if Value then
                Values.weaponSpeed = function(...) return originalWeaponSpeed(...) / 10 end
            else
                Values.weaponSpeed = originalWeaponSpeed
            end
        end
    })

    local isAutoEquipSwordEnabled = false
    local EquipBest = HalloweenMobsSection:Toggle("AutoEquipBestSword", {
        Title = "Auto Equip Best Sword",
        Description = "Automatically equips the best Halloween sword you own.",
        Default = false,
        Callback = function(enabled)
            isAutoEquipSwordEnabled = enabled
            if enabled then
                task.spawn(function()
                    while isAutoEquipSwordEnabled do
                        pcall(function()
                            local HalloweenEventItems = require(ReplicatedStorage.Shared.List.Items.HalloweenEvent)
                            local playerData = DataController:getData()
                            
                            if not playerData.inventory or not playerData.inventory.halloweenEvent then return end
                            local bestSwordIndex = -1
                            local bestInventoryId = nil
                            for inventoryId, itemData in pairs(playerData.inventory.halloweenEvent) do
                                local itemStats = HalloweenEventItems[itemData.nm]
                                if itemStats and itemStats.index and (itemData.nm:lower():find("sword") or itemData.nm:lower():find("blade")) then
                                    if itemStats.index > bestSwordIndex then
                                        bestSwordIndex = itemStats.index
                                        bestInventoryId = inventoryId
                                    end
                                end
                            end

                            if not bestInventoryId then return end

                            if not playerData.isHalloweenWeaponEquipped then
                                Knit.GetService("InventoryService"):useItem(bestInventoryId)
                            else
                                local currentInventoryId = nil
                                for inventoryId, itemData in pairs(playerData.inventory.halloweenEvent) do
                                    if itemData.nm and (itemData.nm:lower():find("sword") or itemData.nm:lower():find("blade")) then
                                        currentInventoryId = inventoryId
                                        break
                                    end
                                end

                                if currentInventoryId ~= bestInventoryId then
                                     Knit.GetService("InventoryService"):useItem(bestInventoryId)
                                end
                            end
                        end)
                        task.wait(5)
                    end
                end)
            end
        end
    })

    local SwordUpgradesSection = Tabs.Halloween:AddSection("Sword Upgrades")

    local autoUpgradeSwordThread, originalAutoHitSettings = nil, nil

    -- Helper function to find raw item data from player's inventory
    local function findRawItem(playerData, itemName)
        if not playerData or not playerData.inventory then return nil end
        for category, items in pairs(playerData.inventory) do
            if type(items) == "table" then
                for _, data in pairs(items) do
                    if type(data) == "table" and data.nm == itemName then return data end
                end
            end
        end
        return nil
    end
    
    -- Helper map to find which mobs drop which materials
    local function generateItemSourceMap()
        local sources = {}
        local mobs = require(ReplicatedStorage.Shared.List.Halloween.Mobs)
        for mobId, mobData in pairs(mobs) do
            for _, reward in ipairs(mobData.rewards or {}) do
                if reward.item and reward.item.nm then
                    sources[reward.item.nm] = sources[reward.item.nm] or {}
                    table.insert(sources[reward.item.nm], mobId)
                end
            end
        end
        return sources
    end
    local itemSourceMap = generateItemSourceMap()

    -- The status paragraph that updates every second
    local upgradeStatusParagraph = SwordUpgradesSection:Paragraph("UpgradeStatus", {
        Title = "Upgrade Progress",
        Content = "Loading...",
        TitleAlignment = "Left"
    })

    -- Background task to keep the status paragraph updated
    task.spawn(function()
        while true do
            pcall(function()
                local playerData = DataController:getData()
                if not playerData then return end

                local HalloweenItems = require(ReplicatedStorage.Shared.List.Items.HalloweenEvent)
                local WeaponUpgrader = require(ReplicatedStorage.Shared.List.Halloween.WeaponUpgrader)

                -- Find current and next weapon
                local currentWeaponIndex, currentWeaponName = -1, "None"
                for _, itemData in pairs(playerData.inventory.halloweenEvent or {}) do
                    local itemStats = HalloweenItems[itemData.nm]
                    if itemStats and itemStats.index and itemStats.index > currentWeaponIndex then
                        currentWeaponIndex = itemStats.index
                        currentWeaponName = itemStats.name
                    end
                end

                local nextWeaponName = nil
                for name, data in pairs(HalloweenItems) do
                    if data.index and data.index == currentWeaponIndex + 1 then
                        nextWeaponName = name; break
                    end
                end
                
                local contentLines = {"Current: " .. currentWeaponName}
                if not nextWeaponName then
                    table.insert(contentLines, "\n🎉 You have the BEST weapon!")
                else
                    local recipe = WeaponUpgrader[nextWeaponName]
                    table.insert(contentLines, "Next: " .. HalloweenItems[nextWeaponName].name .. "\n")
                    
                    for _, reqItem in ipairs(recipe.required) do
                        local itemName = reqItem:getName()
                        local needed = reqItem:getAmount()
                        local current = (findRawItem(playerData, itemName) or {am=0}).am
                        local status = (current >= needed) and "✅" or "❌"
                        table.insert(contentLines, string.format("%s %s: %s / %s", status, itemName, Functions.suffixes(current), Functions.suffixes(needed)))
                    end
                end
                upgradeStatusParagraph:SetValue(table.concat(contentLines, "\n"))
            end)
            task.wait(1)
        end
    end)

    local AutoUpgradeSwordToggle = SwordUpgradesSection:Toggle("AutoUpgradeSword", {
        Title = "Auto Upgrade Sword",
        Description = "Automatically upgrades your sword and farms only the necessary materials.",
        Default = false,
        Callback = function(enabled)
            if autoUpgradeSwordThread then task.cancel(autoUpgradeSwordThread); autoUpgradeSwordThread = nil end

            if enabled then
                originalAutoHitSettings = { selectedMobs = mobDropdown.Value, autoHitState = AutoHitToggle.Value, EquipBestState = EquipBest.Value, HitSpeedState = HitSpeed.Value }
                
                autoUpgradeSwordThread = task.spawn(function()
                    while enabled do
                        pcall(function()
                            local playerData = DataController:getData()
                            local HalloweenItems = require(ReplicatedStorage.Shared.List.Items.HalloweenEvent)
                            local WeaponUpgrader = require(ReplicatedStorage.Shared.List.Halloween.WeaponUpgrader)
                            local MobsModule = require(ReplicatedStorage.Shared.List.Halloween.Mobs)

                            -- Find current and next weapon
                            local currentWeaponIndex = -1
                            for _, itemData in pairs(playerData.inventory.halloweenEvent or {}) do
                                local itemStats = HalloweenItems[itemData.nm]
                                if itemStats and itemStats.index and itemStats.index > currentWeaponIndex then currentWeaponIndex = itemStats.index end
                            end
                            local nextWeaponName = nil
                            for name, data in pairs(HalloweenItems) do
                                if data.index and data.index == currentWeaponIndex + 1 then nextWeaponName = name; break end
                            end
                            if not nextWeaponName then 
                                AutoHitToggle:SetValue(false) -- Max weapon, so turn off farming
                                return 
                            end

                            -- Check requirements and separate missing materials
                            local canAfford, missingMaterials, isMissingCandy = true, {}, false
                            for _, reqItem in ipairs(WeaponUpgrader[nextWeaponName].required) do
                                local itemName, needed = reqItem:getName(), reqItem:getAmount()
                                if (findRawItem(playerData, itemName) or {am=0}).am < needed then
                                    canAfford = false
                                    if itemName == "candyCorns" then
                                        isMissingCandy = true
                                    else
                                        table.insert(missingMaterials, itemName)
                                    end
                                end
                            end

                            if canAfford then
                                Knit.GetService("HalloweenWeaponService"):upgradeWeapon()
                                task.wait(2)
                            else
                                -- NEW FARMING LOGIC
                                local mobsToFarm = {}
                                
                                -- Priority 1: Farm specific mobs for non-candy materials
                                if #missingMaterials > 0 then
                                    for _, material in ipairs(missingMaterials) do
                                        if itemSourceMap[material] then
                                            for _, mobId in ipairs(itemSourceMap[material]) do
                                                mobsToFarm[mobId:lower()] = true
                                            end
                                        end
                                    end
                                -- Priority 2: If ONLY candy is missing, farm the best mob for it
                                elseif isMissingCandy then
                                    local bestSwordInfo, bestIndex = nil, -1
                                    for _, itemData in pairs(playerData.inventory.halloweenEvent) do
                                        local itemStats = HalloweenItems[itemData.nm]
                                        if itemStats and itemStats.index and itemStats.index > bestIndex then bestIndex, bestSwordInfo = itemStats.index, itemStats end
                                    end
                                    if bestSwordInfo then
                                        local damageLimit = bestSwordInfo.multiplier * 25
                                        local viableTargets = {}
                                        for mobId, mobData in pairs(MobsModule) do
                                            if mobData.hp <= damageLimit then table.insert(viableTargets, {id = mobId, data = mobData}) end
                                        end
                                        if #viableTargets > 0 then
                                            table.sort(viableTargets, function(a,b) return a.data.hp > b.data.hp end)
                                            mobsToFarm[viableTargets[1].id:lower()] = true
                                        end
                                    end
                                end

                                -- Update UI
                                local newSelection = {}
                                for mobId, _ in pairs(mobsToFarm) do
                                    for _, mobValue in ipairs(mobDropdown.Values) do
                                        if mobValue:lower() == mobId:lower() then newSelection[mobValue] = true end
                                    end
                                end
                                mobDropdown:SetValue(newSelection)
                                HitSpeed:SetValue(next(newSelection) ~= nil)
                                EquipBest:SetValue(next(newSelection) ~= nil)
                                AutoHitToggle:SetValue(next(newSelection) ~= nil)
                            end
                        end)
                        task.wait(2)
                    end
                end)
            else
                if originalAutoHitSettings then
                    mobDropdown:SetValue(originalAutoHitSettings.selectedMobs)
                    AutoHitToggle:SetValue(originalAutoHitSettings.autoHitState)
                    EquipBest:SetValue(originalAutoHitSettings.EquipBestState)
                    HitSpeed:SetValue(originalAutoHitSettings.HitSpeedState)
                    originalAutoHitSettings = nil
                end
            end
        end
    })

    
    local HalloweenRebirthSection = Tabs.Halloween:AddSection("Halloween Rebirth")

    local autoRebirthThread, originalAutoHitSettings = nil, nil

    -- NEW: This function dynamically builds a map of items that have ONLY ONE mob source.
    local function generateUniqueDropMap()
        local uniqueMap = {}
        pcall(function()
            local mobs = require(ReplicatedStorage.Shared.List.Halloween.Mobs)
            local itemSources = {} -- First, find ALL sources for each item
            for mobId, mobData in pairs(mobs) do
                for _, reward in ipairs(mobData.rewards or {}) do
                    if reward.item and reward.item.nm then
                        itemSources[reward.item.nm] = itemSources[reward.item.nm] or {}
                        table.insert(itemSources[reward.item.nm], mobId)
                    end
                end
            end
            -- Now, filter for the ones with only one source
            for itemName, sources in pairs(itemSources) do
                if #sources == 1 then
                    uniqueMap[itemName] = sources[1] -- Map item name directly to the single mobId
                end
            end
        end)
        return uniqueMap
    end
    local uniqueDropMap = generateUniqueDropMap()

    local function findRawItem(playerData, itemName)
        if not playerData or not playerData.inventory then return nil end
        for _, items in pairs(playerData.inventory) do
            if type(items) == "table" then for _, data in pairs(items) do if type(data) == "table" and data.nm == itemName then return data end end end
        end
        return nil
    end

    local rebirthStatusParagraph = HalloweenRebirthSection:Paragraph("RebirthStatus", {
        Title = "Next Rebirth Progress",
        Content = "Loading...",
        TitleAlignment = "Middle"
    })

    task.spawn(function() while true do pcall(function()
        local data=DataController:getData(); if not data then return end; local list=require(ReplicatedStorage.Shared.List.Halloween.HalloweenRebirths)
        local cur=data.halloweenRebirths or 0; local nxt=cur+1; local reqs=list[nxt]
        local lines={"Current Rebirths: "..cur}; if not reqs then table.insert(lines,"\n🎉 MAXIMUM REBIRTH LEVEL!") else
        table.insert(lines,"Target: Rebirth "..nxt.."\n"); table.insert(lines,string.format("Candy Corns: %s / %s",Functions.suffixes((findRawItem(data,"candyCorns")or{am=0}).am),Functions.suffixes(reqs.candyCorns)))
        for _,rItem in ipairs(reqs.required or {}) do table.insert(lines,string.format("%s: %s / %s",rItem:getName(),Functions.suffixes((findRawItem(data,rItem:getName())or{am=0}).am),Functions.suffixes(rItem:getAmount()))) end
        end; rebirthStatusParagraph:SetValue(table.concat(lines,"\n"))
    end); task.wait(3) end end)
    
    local AutoRebirthToggle = HalloweenRebirthSection:Toggle("AutoRebirth", {
        Title = "Auto Rebirth",
        Description = "WARNING: Resets Candy Corns. This will farm mobs for needed materials.",
        Default = false,
        Callback = function(enabled)
            if autoRebirthThread then task.cancel(autoRebirthThread); autoRebirthThread = nil end

            if enabled then
                originalAutoHitSettings = { selectedMobs = mobDropdown.Value, autoHitState = AutoHitToggle.Value, EquipBestState = EquipBest.Value, HitSpeedState = HitSpeed.Value }
                
                autoRebirthThread = task.spawn(function()
                    while enabled do
                        pcall(function()
                            local playerData = DataController:getData()
                            local HalloweenRebirths = require(ReplicatedStorage.Shared.List.Halloween.HalloweenRebirths)
                            local currentRebirths = playerData.halloweenRebirths or 0
                            
                            local mobsToFarm = {}
                            local foundPriorityTarget = false

                            -- Find the EARLIEST future rebirth with missing UNIQUE materials
                            for tier = currentRebirths + 1, #HalloweenRebirths do
                                for _, reqItem in ipairs(HalloweenRebirths[tier].required or {}) do
                                    local itemName = reqItem:getName()
                                    -- Check if this item has a unique source
                                    if uniqueDropMap[itemName] then
                                        local playerAmount = (findRawItem(playerData, itemName) or {am=0}).am
                                        if playerAmount < reqItem:getAmount() then
                                            -- We have a deficit for a uniquely dropped item. This is our target.
                                            mobsToFarm[uniqueDropMap[itemName]] = true
                                            foundPriorityTarget = true
                                        end
                                    end
                                end
                                -- If we found any mobs to farm for this tier, stop looking at later tiers
                                if foundPriorityTarget then break end
                            end
                            
                            -- Update the Auto Hit UI based on our findings
                            local finalTargets = {}; for mobId in pairs(mobsToFarm) do table.insert(finalTargets, mobId) end
                            local newSelection = {}; if #finalTargets > 0 then
                                for _, mobIdValue in ipairs(mobDropdown.Values) do
                                    for _, targetId in ipairs(finalTargets) do
                                        if mobIdValue:lower() == targetId:lower() then newSelection[mobIdValue] = true; break end
                                    end
                                end
                            end
                            mobDropdown:SetValue(newSelection)
                            AutoHitToggle:SetValue(#finalTargets > 0)
                            EquipBest:SetValue(next(newSelection) ~= nil)
                            HitSpeed:SetValue(next(newSelection) ~= nil)

                            -- Check if the CURRENT rebirth is affordable and execute
                            local currentRequirements = HalloweenRebirths[currentRebirths + 1]
                            if currentRequirements then
                                local canAfford = true
                                if (findRawItem(playerData, "candyCorns") or {am=0}).am < currentRequirements.candyCorns then canAfford = false end
                                for _, reqItem in ipairs(currentRequirements.required or {}) do
                                    if (findRawItem(playerData, reqItem:getName()) or {am=0}).am < reqItem:getAmount() then canAfford = false; break end
                                end
                                if canAfford then
                                    Knit.GetService("HalloweenService"):halloweenRebirth()
                                    task.wait(2)
                                end
                            end
                        end)
                        task.wait(3)
                    end
                end)
            else
                if originalAutoHitSettings then
                    mobDropdown:SetValue(originalAutoHitSettings.selectedMobs)
                    AutoHitToggle:SetValue(originalAutoHitSettings.autoHitState)
                    EquipBest:SetValue(originalAutoHitSettings.EquipBestState)
                    HitSpeed:SetValue(originalAutoHitSettings.HitSpeedState)
                    originalAutoHitSettings = nil
                end
            end
        end
    })
    
    local BossCaveSection = Tabs.Halloween:AddSection("Boss Cave")

    local autoCaveThread, originalToggleStates = nil, nil
    
    local isEventStartingSoon = false
    local inCaveTimer = "N/A"

    local caveTimerParagraph = BossCaveSection:Paragraph("CaveTimer", {
        Title = "Boss Cave Status",
        Content = "Initializing..."
    })

    -- Background task to read the in-game timer from the GUI
    task.spawn(function()
        local timerLabel = LocalPlayer:WaitForChild("PlayerGui"):WaitForChild("MainUI"):WaitForChild("HUD"):WaitForChild("Bars"):WaitForChild("BossCave"):WaitForChild("Timer")
        
        while true do
            pcall(function()
                local currentText = timerLabel.Text
                inCaveTimer = (currentText ~= "" and currentText) or "N/A"
                
                local cycle = (Knit.serverTimeNow - 3600) % 10800
                isEventStartingSoon = cycle <= 300
                local time = isEventStartingSoon and 300 - cycle or 10800 - cycle
                local status = isEventStartingSoon and "Starts in: %s" or "Opens in: %s"
                
                local statusText = status:format(Functions.formatTime(time)) .. "\nIn-Cave Time: " .. inCaveTimer
                caveTimerParagraph:SetValue(statusText)
            end)
            task.wait(1)
        end
    end)

    do
    -- Store these as upvalues so they persist across enable/disable calls
        local autoCaveThread = nil
        local originalToggleStates = nil

        BossCaveSection:Toggle("AutoJoinAndFight", {
            Title = "Auto Join + Fight",
            Description = "Joins the cave and fights the mobs. Temporarily disables other farming mob toggles while in the cave.",
            Default = false,
            Callback = function(enabled)
                if autoCaveThread then task.cancel(autoCaveThread); autoCaveThread = nil end

                if enabled then
                    -- NOTE: We no longer save originalToggleStates here. It will be saved just-in-time.
                    
                    autoCaveThread = task.spawn(function()
                        local hasPausedOtherToggles = false
                        local currentTargetId = nil
                        
                        while task.wait(0.25) do -- Using task.wait at the top of the loop is a common, clean pattern
                            pcall(function()
                                local cycle = (Knit.serverTimeNow - 3600) % 10800
                                
                                -- Define the conditions for when the script should be active in the cave
                                local isJoiningTime = isEventStartingSoon and cycle >= 270 and cycle <= 300
                                local isInCave = inCaveTimer ~= "N/A" and inCaveTimer ~= "00:00"

                                -- State 1 & 2: Active Phase (Joining or Fighting)
                                if isJoiningTime or isInCave then
                                    
                                    -- This block runs only ONCE per event cycle, at the very beginning.
                                    if not hasPausedOtherToggles then
                                        hasPausedOtherToggles = true
                                        print("[Boss Cave] Event active. Saving current settings and pausing other toggles.")
                                        
                                        -- SAVE THE STATES HERE, right before we need them.
                                        originalToggleStates = {
                                            autoRebirth = AutoRebirthToggle.Value, autoUpgrade = AutoUpgradeSwordToggle.Value,
                                            autoHitMobs = AutoHitToggle.Value, equipBest = EquipBest.Value, hitSpeed = HitSpeed.Value,
                                        }
                                        
                                        -- Disable other toggles and enable cave-specific ones
                                        task.defer(function() 
                                            AutoRebirthToggle:SetValue(false)
                                            AutoUpgradeSwordToggle:SetValue(false)
                                            AutoHitToggle:SetValue(false)
                                            EquipBest:SetValue(true)
                                            HitSpeed:SetValue(true) 
                                        end)
                                    end
                                    
                                    -- Joining Logic (runs during the 30-second window)
                                    if isJoiningTime then
                                        print("[Boss Cave] Attempting to join...")
                                        Knit.GetService("BossCaveService"):joinBossCave()
                                        task.wait(9) -- Wait a bit after a join attempt to avoid spam
                                    end
                                    
                                    -- Fighting Logic (runs only when inside the cave)
                                    if isInCave then
                                        local isTargetValid = false
                                        if currentTargetId then
                                            for _, mob in ipairs(game:GetService("CollectionService"):GetTagged("bossCaveMob")) do
                                                if mob:GetAttribute("mobId") == currentTargetId then
                                                    isTargetValid = true
                                                    break
                                                end
                                            end
                                        end

                                        if not isTargetValid then
                                            currentTargetId = nil
                                            local allMobs = game:GetService("CollectionService"):GetTagged("bossCaveMob")
                                            if #allMobs > 0 then
                                                currentTargetId = allMobs[1]:GetAttribute("mobId")
                                            end
                                        end
                                        
                                        if currentTargetId then
                                            Knit.GetService("BossCaveService").damage._re:FireServer(currentTargetId)
                                        end
                                    end
                                
                                -- State 3: Restoration Phase
                                elseif hasPausedOtherToggles then
                                    print("[Boss Cave] Event ended or left cave. Restoring original toggle states.")
                                    
                                    -- Restore settings only if we have a saved state
                                    if originalToggleStates then
                                        task.defer(function() 
                                            AutoRebirthToggle:SetValue(originalToggleStates.autoRebirth)
                                            AutoUpgradeSwordToggle:SetValue(originalToggleStates.autoUpgrade)
                                            AutoHitToggle:SetValue(originalToggleStates.autoHitMobs)
                                            EquipBest:SetValue(originalToggleStates.equipBest)
                                            HitSpeed:SetValue(originalToggleStates.hitSpeed)
                                        end)
                                    end
                                    
                                    -- Reset state for the next cycle
                                    hasPausedOtherToggles = false
                                    currentTargetId = nil
                                    print("[Boss Cave] Restoration complete. Awaiting next event.")
                                end
                            end)
                        end
                    end)
                else -- This runs when the master toggle is turned OFF
                    -- Safely restore settings if they were ever saved
                    if originalToggleStates then
                        print("[Boss Cave] Master toggle disabled. Restoring all original settings.")
                        task.defer(function()
                            AutoRebirthToggle:SetValue(originalToggleStates.autoRebirth)
                            AutoUpgradeSwordToggle:SetValue(originalToggleStates.autoUpgrade)
                            AutoHitToggle:SetValue(originalToggleStates.autoHitMobs)
                            EquipBest:SetValue(originalToggleStates.equipBest)
                            HitSpeed:SetValue(originalToggleStates.hitSpeed)
                        end)
                        originalToggleStates = nil -- Clear the saved state
                    end
                end
            end
        })
    end

    BossCaveSection:Toggle("ClaimBossChest", {
        Title = "Claim Boss Chest",
        Description = "Automatically claims the Boss Chest.",
        Default = false,
        Callback = function(enabled)
            local claimThread
            if claimThread then task.cancel(claimThread) end

            if enabled then
                claimThread = task.spawn(function()
                    while enabled do
                        pcall(function()
                            Knit.GetService("BossCaveService"):claimBossChest()
                        end)
                        task.wait(10)
                    end
                end)
            end
        end
    })


    local ForestUpgradesSection = Tabs.Halloween:AddSection("Forest Upgrades")

    local forestUpgradeNames, ForestUpgradesModule, forestAutoUpgradeThread = {}, nil, nil

    pcall(function()
        ForestUpgradesModule = require(ReplicatedStorage.Shared.List.Halloween.ForestUpgrades)
        for name, _ in pairs(ForestUpgradesModule) do table.insert(forestUpgradeNames, name) end
        table.sort(forestUpgradeNames)
    end)
    
    if #forestUpgradeNames > 0 then
        local upgradesDropdown = ForestUpgradesSection:Dropdown("ForestUpgradesDropdown", {
            Title = "Select Forest Upgrades",
            Values = forestUpgradeNames,
            Multi = true,
            Searchable = true,
            Default = {}
        })

        ForestUpgradesSection:Toggle("AutoUpgradeForest", {
            Title = "Auto Upgrade",
            Description = "Automatically buys selected upgrades when you can afford them.",
            Default = false,
            Callback = function(enabled)
                if forestAutoUpgradeThread then task.cancel(forestAutoUpgradeThread); forestAutoUpgradeThread = nil end
                if enabled then
                    forestAutoUpgradeThread = task.spawn(function()
                        while enabled do
                            pcall(function()
                                local selectedUpgrades = upgradesDropdown.Value
                                if not next(selectedUpgrades) then return end
                                local playerData = DataController:getData()
                                for upgradeName, isSelected in pairs(selectedUpgrades) do
                                    if not enabled then break end
                                    if isSelected then
                                        local currentLevel = (playerData.forestUpgrades and playerData.forestUpgrades[upgradeName]) or 0
                                        local upgradeInfo = ForestUpgradesModule[upgradeName]
                                        local nextUpgradeData = upgradeInfo and upgradeInfo.upgrades and upgradeInfo.upgrades[currentLevel + 1]
                                        if nextUpgradeData then
                                            local cost = nextUpgradeData.cost
                                            local playerItem = Util.itemUtils.getItemFromName(playerData, cost:getName())
                                            local playerAmount = playerItem and playerItem:getAmount() or 0
                                            if playerAmount >= cost:getAmount() then
                                                UpgradeService:upgradeForest(upgradeName)
                                                task.wait(1) 
                                            end
                                        end
                                    end
                                end
                            end)
                            task.wait(5) 
                        end
                    end)
                end
            end
        })
    end
    
    -- Final UI setup calls
    SaveManager:SetLibrary(Library)
    InterfaceManager:SetLibrary(Library)
    SaveManager:IgnoreThemeSettings()
    SaveManager:SetIgnoreIndexes{}
    InterfaceManager:SetFolder("FluentScriptHub")
    SaveManager:SetFolder("FluentScriptHub/specific-game")
    InterfaceManager:BuildInterfaceSection(Tabs.Settings)
    SaveManager:BuildConfigSection(Tabs.Settings)
    Window:SelectTab(1)
    SaveManager:LoadAutoloadConfig()
end

task.spawn(function()
    if not game:IsLoaded() then game.Loaded:Wait() end

    -- Initialize Knit and all necessary game services/controllers first
    Knit = require(ReplicatedStorage.Packages.Knit)
    Knit.OnStart():await()

    ClickService = Knit.GetService("ClickService")
    UpgradeService = Knit.GetService("UpgradeService")
    
    DataController = Knit.GetController("DataController")
    
    Functions = require(ReplicatedStorage.Shared.Functions)
    Util = require(ReplicatedStorage.Shared.Util)
    Values = require(ReplicatedStorage.Shared.Values)   

    -- Now that services are ready, build the UI
    Window = Library:Window{
        Title = "RCU - Halloween",
        SubTitle = "By Duckie",
        TabWidth = 160,
        Size =  UDim2.fromOffset(580, 460),
        Resize = false,
        Theme = "Darker",
        MinimizeKey = Enum.KeyCode.LeftShift
    }

    Tabs = {
        Halloween = Window:AddTab({ Title = "Halloween Event", Icon = "ghost" }),
        Settings = Window:AddTab({ Title = "Settings", Icon = "cog" }),
    }

    -- Finally, call BuildUI to create all the sections
    BuildUI()
end)
